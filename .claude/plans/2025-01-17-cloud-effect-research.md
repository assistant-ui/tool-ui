# Cloud Effect Research: Volumetric Rendering Techniques

## Executive Summary

Realistic cloud rendering requires **volumetric ray marching** through density fields generated by **layered noise functions** (FBM). Light transport uses the **Beer-Lambert law** for absorption and **phase functions** for scattering. The gold standard is Guerrilla Games' **Nubis system** from Horizon Zero Dawn, which achieves 2ms GPU performance with physically-accurate results.

---

## Part 1: The Physics of Clouds

### Cloud Formation & Types

Clouds form when water vapor condenses around particles in the atmosphere. Different conditions create distinct cloud types:

| Cloud Type | Altitude | Shape | Visual Characteristics |
|------------|----------|-------|------------------------|
| **Cumulus** | Low (2km) | Puffy, dome-topped | Bright white tops, dark flat bases, cauliflower-like, sharp edges |
| **Stratus** | Low (2km) | Flat, sheet-like | Gray to white, uniform, smooth texture |
| **Cirrus** | High (6km+) | Wispy, feathery | White, delicate filaments, fibrous/silky, ice crystals |
| **Stratocumulus** | Low-Mid | Clumped layers | Mix of stratus sheets and cumulus cells |
| **Cumulonimbus** | All levels | Towering, anvil-topped | Dense, dramatic, produces storms |

### Light Interaction in Clouds

Light in clouds undergoes:
1. **Absorption** - Energy converted to heat (minimal in water droplets)
2. **Scattering** - Light redirected by water droplets (dominant effect)
3. **Multiple scattering** - Light bounces many times before exiting

Key phenomena:
- **Silver lining**: Forward scattering at cloud edges (Mie scattering)
- **Dark bases**: Light absorbed/scattered on long paths through dense cloud
- **Bright tops**: Direct sunlight with minimal path through cloud

---

## Part 2: Noise Functions for Cloud Density

### Fractal Brownian Motion (FBM)

FBM layers multiple noise octaves at different scales:

```glsl
float fbm(vec3 p, int octaves) {
  float value = 0.0;
  float amplitude = 0.5;
  float frequency = 1.0;

  for (int i = 0; i < octaves; i++) {
    value += amplitude * noise(p * frequency);
    amplitude *= 0.5;      // gain/persistence
    frequency *= 2.0;      // lacunarity
  }
  return value;
}
```

**Parameters:**
- **Octaves**: Number of layers (3-8 typical, more = finer detail)
- **Lacunarity**: Frequency multiplier per octave (typically 2.0)
- **Gain/Persistence**: Amplitude multiplier per octave (typically 0.5)

### Perlin vs Worley Noise

**Perlin Noise**: Smooth, continuous gradients - good for base cloud shape
**Worley Noise**: Cellular, creates "billowy" appearance - good for cumulus detail

Horizon Zero Dawn combines both:
1. Red channel: 2 layers Perlin + 1 layer Worley (low frequency base)
2. Green/Blue/Alpha: 3 layers higher-frequency Worley (detail)

### Density Function

```glsl
float cloudDensity(vec3 p) {
  // Animate with time
  vec3 q = p + vec3(0.0, 0.1, 1.0) * time;

  // Base shape from FBM
  float density = fbm(q, 4);

  // Height gradient (denser at bottom, wispy at top)
  density -= p.y * 0.5;

  // Threshold and clamp
  return clamp(density * 2.0 - 1.0, 0.0, 1.0);
}
```

---

## Part 3: Ray Marching Algorithm

### Core Loop

```glsl
vec4 raymarchClouds(vec3 rayOrigin, vec3 rayDir, vec3 bgColor) {
  vec4 result = vec4(0.0);
  float t = 0.0;

  for (int i = 0; i < MAX_STEPS; i++) {
    vec3 pos = rayOrigin + t * rayDir;

    // Early exit if fully opaque
    if (result.a > 0.99) break;

    float density = cloudDensity(pos);

    if (density > 0.01) {
      // Calculate lighting at this point
      vec3 color = cloudLighting(pos, density, bgColor);

      // Front-to-back compositing
      float alpha = density * stepSize;
      result.rgb += color * alpha * (1.0 - result.a);
      result.a += alpha * (1.0 - result.a);
    }

    // Adaptive step size (larger when far from camera)
    t += max(0.05, 0.02 * t);
  }

  return result;
}
```

### Step Size Strategies

| Strategy | Description | Use Case |
|----------|-------------|----------|
| Fixed | Constant step size | Simple, predictable |
| Adaptive | `step = max(minStep, factor * distance)` | General purpose |
| SDF-guided | Step by distance to nearest surface | When SDF available |
| Empty space skipping | Large steps in low-density regions | Performance critical |

---

## Part 4: Lighting & Beer-Lambert Law

### Transmittance

The Beer-Lambert law models light absorption:

```
T = e^(-σ × d)
```

Where:
- `T` = transmittance (0-1, how much light passes through)
- `σ` = extinction coefficient (absorption + scattering)
- `d` = distance traveled through medium

```glsl
float transmittance(float density, float distance) {
  float extinction = 0.1;  // Tune this
  return exp(-extinction * density * distance);
}
```

### Self-Shadowing

To compute how much light reaches a point inside the cloud:

```glsl
float lightTransmittance(vec3 pos, vec3 lightDir) {
  float shadow = 0.0;
  float t = 0.0;

  for (int i = 0; i < SHADOW_STEPS; i++) {
    vec3 samplePos = pos + lightDir * t;
    shadow += cloudDensity(samplePos);
    t += SHADOW_STEP_SIZE;
  }

  return exp(-shadow * SHADOW_EXTINCTION);
}
```

### Gradient Lighting (Approximation)

A cheaper approximation samples density in the light direction:

```glsl
vec3 cloudLighting(vec3 pos, float density, vec3 bgColor) {
  // Sample density toward sun
  float densityTowardSun = cloudDensity(pos + sunDir * 0.3);

  // Gradient = how much denser toward sun (higher = more lit)
  float gradient = clamp(density - densityTowardSun, 0.0, 1.0);

  // Lit color (warm sunlight at edges)
  vec3 litColor = vec3(1.0, 0.95, 0.8) + vec3(1.0, 0.6, 0.3) * gradient;

  // Cloud albedo varies with density
  vec3 albedo = mix(vec3(1.0, 0.95, 0.85), vec3(0.4, 0.45, 0.5), density);

  return albedo * litColor;
}
```

### Phase Functions

Phase functions describe directional scattering probability:

**Henyey-Greenstein** (common approximation):
```glsl
float henyeyGreenstein(float cosTheta, float g) {
  float g2 = g * g;
  return (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * cosTheta, 1.5) / (4.0 * PI);
}
```

- `g = 0`: Isotropic (equal in all directions)
- `g > 0`: Forward scattering (silver lining effect)
- `g < 0`: Back scattering

---

## Part 5: Optimization Techniques

### Performance Targets

| Platform | Target | Technique |
|----------|--------|-----------|
| AAA Games | 2ms | All optimizations, temporal reprojection |
| Real-time | 8ms | Reduced steps, lower resolution |
| WebGL | 16ms | Minimal steps, pre-baked textures |

### Key Optimizations

1. **Reduced Resolution**: Render clouds at 1/4 resolution, upscale
2. **Temporal Reprojection**: Reuse samples from previous frames
3. **Blue Noise Dithering**: Hide banding from low step counts
4. **Empty Space Skipping**: Jump through regions with zero density
5. **Early Ray Termination**: Stop when opacity reaches ~99%
6. **3D Noise Textures**: Pre-compute noise, sample with `textureLod`
7. **Fewer Octaves**: 3-4 octaves instead of 8 for real-time

### Inigo Quilez's 4-Sample Trick

Store pre-offset noise samples in texture channels:
- R: noise at step 3
- G: noise at step 2
- B: noise at step 1
- A: noise at step 0

Single texture fetch gives 4 density samples along the ray.

### Blue Noise Dithering

```glsl
// Offset ray start by blue noise to hide stepping artifacts
float blueNoise = texture(blueNoiseTexture, gl_FragCoord.xy / 256.0).r;
float startOffset = blueNoise * stepSize;
```

---

## Part 6: Implementation Approaches

### Option A: 2D Skybox Clouds (Fast)

- Render noise on a dome/plane
- Good for distant clouds
- No volumetric lighting
- Very fast (fragment shader only)

### Option B: Ray Marched Volume (Quality)

- Full volumetric ray marching
- Self-shadowing and scattering
- Expensive but realistic
- Best for dramatic cloudscapes

### Option C: Hybrid (Balanced)

- 2D base layer for distant clouds
- Ray marching only near camera
- LOD transitions between techniques

### Recommended for WebGL

Start with **2D clouds using animated FBM**, then optionally add:
1. Height-based density gradients
2. Simple light direction shading
3. Animated wind displacement
4. Multiple cloud layers at different altitudes

If performance allows, upgrade to:
1. Simple ray marching (8-16 steps)
2. Blue noise dithering
3. Pre-computed 3D noise texture

---

## Part 7: Reference Shader Structure

```glsl
// Uniforms
uniform float u_time;
uniform vec3 u_sunDirection;
uniform float u_cloudCoverage;
uniform float u_cloudDensity;
uniform float u_windSpeed;

// Constants
#define MAX_STEPS 64
#define SHADOW_STEPS 4

// Noise (use 3D texture for performance)
float cloudNoise(vec3 p) {
  return fbm(p, 4);
}

// Density with height gradient
float cloudDensityField(vec3 p) {
  vec3 windOffset = vec3(u_time * u_windSpeed, 0.0, u_time * u_windSpeed * 0.5);
  float noise = cloudNoise((p + windOffset) * 0.001);

  // Height falloff (clouds between 1000-3000m)
  float heightFade = smoothstep(1000.0, 1500.0, p.y) * smoothstep(3000.0, 2500.0, p.y);

  // Coverage threshold
  float density = noise - (1.0 - u_cloudCoverage);

  return max(0.0, density * heightFade * u_cloudDensity);
}

// Main
void main() {
  vec3 rayDir = normalize(v_worldPos - u_cameraPos);
  vec3 color = raymarchClouds(u_cameraPos, rayDir, skyColor);
  fragColor = vec4(color, 1.0);
}
```

---

## Part 8: Quality Checklist

For realistic cloud rendering:

- [ ] Multiple noise octaves (FBM) for organic detail
- [ ] Height-based density gradient
- [ ] Darker bases, brighter tops
- [ ] Silver lining / rim lighting from sun
- [ ] Animated wind movement
- [ ] Smooth transitions in/out of clouds
- [ ] Blue noise dithering to hide stepping
- [ ] Temporal stability (no flickering)
- [ ] Performance within budget

---

## Sources

### Presentations
- [Guerrilla Games: Real-time Volumetric Cloudscapes of Horizon Zero Dawn](https://www.guerrilla-games.com/read/the-real-time-volumetric-cloudscapes-of-horizon-zero-dawn) (SIGGRAPH 2015)
- [Guerrilla Games: Nubis System](https://www.guerrilla-games.com/read/nubis-authoring-real-time-volumetric-cloudscapes-with-the-decima-engine) (SIGGRAPH 2017)
- [GDC: Volumetric Superstorms of Horizon Forbidden West](https://gdcvault.com/play/1028023/The-Real-Time-Volumetric-Superstorms)

### Tutorials
- [Maxime Heckel: Real-time Cloudscapes with Volumetric Raymarching](https://blog.maximeheckel.com/posts/real-time-cloudscapes-with-volumetric-raymarching/)
- [The Book of Shaders: FBM](https://thebookofshaders.com/13/)
- [Inigo Quilez: Dynamic Clouds](https://iquilezles.org/articles/dynclouds/)
- [Scratchapixel: Volume Rendering](https://www.scratchapixel.com/lessons/3d-basic-rendering/volume-rendering-for-developers/intro-volume-rendering.html)

### Code Examples
- [GitHub: danielscherzer/SHADER - Raymarching Clouds](https://github.com/danielscherzer/SHADER/blob/master/raymarching/raymarching%20clouds.glsl)
- [GitHub: CloudNoiseGen - Unity](https://github.com/Fewes/CloudNoiseGen)
- [GitHub: RealTimeVolumetricClouds - Unity](https://github.com/adrianpolimeni/RealTimeVolumetricClouds)

### Research Papers
- [Deep Scattering: Rendering Atmospheric Clouds with Neural Networks](https://arxiv.org/abs/1709.05418) (Disney Research, 2017)
- [Physically Based Real-Time Atmosphere Rendering using Mie Theory](https://onlinelibrary.wiley.com/doi/10.1111/cgf.15010) (2024)
- [Efficient Algorithms for Real-Time GPU Volumetric Cloud Rendering](https://www.mdpi.com/2073-8994/10/4/125)

### Reference
- [NOAA: Ten Basic Cloud Types](https://www.noaa.gov/jetstream/clouds/ten-basic-clouds)
- [Wikipedia: Beer-Lambert Law](https://en.wikipedia.org/wiki/Beer–Lambert_law)
