/**
 * Build-time script to pre-process OpenAI Apps SDK docs into searchable chunks.
 * Run with: pnpm tsx scripts/build-sdk-docs-index.ts
 */

import fs from "fs";
import path from "path";

const DOCS_DIR = path.join(
  process.cwd(),
  "private/reference-docs/openai-apps-sdk"
);
const OUTPUT_FILE = path.join(
  process.cwd(),
  "app/workbench/lib/sdk-guide/docs-index.ts"
);

interface DocChunk {
  id: string;
  source: string;
  heading: string;
  content: string;
  keywords: string[];
}

function extractKeywords(text: string): string[] {
  const stopWords = new Set([
    "the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for",
    "of", "with", "by", "from", "as", "is", "are", "was", "were", "be",
    "been", "being", "have", "has", "had", "do", "does", "did", "will",
    "would", "could", "should", "may", "might", "must", "can", "this",
    "that", "these", "those", "it", "its", "you", "your", "we", "our",
    "they", "their", "if", "when", "where", "what", "which", "who", "how",
    "use", "using", "used", "also", "see", "more", "about", "into",
  ]);

  const words = text
    .toLowerCase()
    .replace(/[^a-z0-9_\s]/g, " ")
    .split(/\s+/)
    .filter((w) => w.length > 2 && !stopWords.has(w));

  const wordFreq = new Map<string, number>();
  for (const word of words) {
    wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
  }

  return Array.from(wordFreq.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 15)
    .map(([word]) => word);
}

function splitByHeadings(content: string, source: string): DocChunk[] {
  const chunks: DocChunk[] = [];
  const lines = content.split("\n");

  let currentHeading = "Overview";
  let currentContent: string[] = [];
  let chunkIndex = 0;

  for (const line of lines) {
    const headingMatch = line.match(/^##\s+(.+)$/);

    if (headingMatch) {
      if (currentContent.length > 0) {
        const contentText = currentContent.join("\n").trim();
        if (contentText.length > 50) {
          chunks.push({
            id: `${source.replace(/\s+/g, "-").toLowerCase()}-${chunkIndex}`,
            source,
            heading: currentHeading,
            content: contentText,
            keywords: extractKeywords(contentText),
          });
          chunkIndex++;
        }
      }
      currentHeading = headingMatch[1];
      currentContent = [];
    } else {
      currentContent.push(line);
    }
  }

  if (currentContent.length > 0) {
    const contentText = currentContent.join("\n").trim();
    if (contentText.length > 50) {
      chunks.push({
        id: `${source.replace(/\s+/g, "-").toLowerCase()}-${chunkIndex}`,
        source,
        heading: currentHeading,
        content: contentText,
        keywords: extractKeywords(contentText),
      });
    }
  }

  return chunks;
}

function processDocsDirectory(): DocChunk[] {
  const allChunks: DocChunk[] = [];
  const files = fs.readdirSync(DOCS_DIR).filter((f) => f.endsWith(".md"));

  for (const file of files) {
    const filePath = path.join(DOCS_DIR, file);
    const content = fs.readFileSync(filePath, "utf-8");
    const source = file.replace(".md", "");
    const chunks = splitByHeadings(content, source);
    allChunks.push(...chunks);
  }

  return allChunks;
}

function generateTypeScriptFile(chunks: DocChunk[]): string {
  return `// Auto-generated by scripts/build-sdk-docs-index.ts
// Do not edit manually

export interface DocChunk {
  id: string;
  source: string;
  heading: string;
  content: string;
  keywords: string[];
}

export const SDK_DOCS_INDEX: DocChunk[] = ${JSON.stringify(chunks, null, 2)};

export const SDK_DOCS_SOURCES = ${JSON.stringify(
    [...new Set(chunks.map((c) => c.source))],
    null,
    2
  )};
`;
}

function main() {
  console.log("Building SDK docs index...");
  console.log(`Source: ${DOCS_DIR}`);
  console.log(`Output: ${OUTPUT_FILE}`);

  const chunks = processDocsDirectory();
  console.log(`Processed ${chunks.length} chunks from ${new Set(chunks.map((c) => c.source)).size} files`);

  const tsContent = generateTypeScriptFile(chunks);
  fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
  fs.writeFileSync(OUTPUT_FILE, tsContent);

  console.log("Done!");
}

main();
