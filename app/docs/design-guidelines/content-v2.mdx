import { DocsHeader } from "../_components/docs-header";

<DocsHeader title="UI Guidelines" />

Design principles and interaction patterns for Tool UIs in conversational AI.

## Why Tool UI Exists

Traditional component libraries (Radix, shadcn/ui) excel at building interfaces. Tool UI is different. It's the first framework designed for components that are:

- **Narrated** by AI assistants
- **Referenced** in natural language  
- **Ephemeral** but referenceable in the transcript
- **Conversation-native** from the ground up

This isn't "components with AI sprinkled on top". It's a fundamental rethink of UI for the age of conversational AI.

Tool UI is the conversation-native layer between your UI primitives (Radix/shadcn) and your AI stack (AI SDK, LangGraph, etc.).

<div className="not-prose">
  <div className="flex items-center justify-between p-4 border rounded-lg">
    <div className="text-center">
      <div className="font-semibold">Radix / shadcn</div>
      <div className="text-sm text-muted-foreground">UI Primitives</div>
    </div>
    <div className="text-center">
      <div className="font-semibold">â†”</div>
    </div>
    <div className="text-center">
      <div className="font-semibold">Tool UI</div>
      <div className="text-sm text-muted-foreground">Conversation-Native</div>
    </div>
    <div className="text-center">
      <div className="font-semibold">â†”</div>
    </div>
    <div className="text-center">
      <div className="font-semibold">AI SDK</div>
      <div className="text-sm text-muted-foreground">LLM Orchestration</div>
    </div>
  </div>
</div>

## Who This Is For

- **Design engineers** building Tool UI components
- **Contributors** to the Tool UI ecosystem
- **LLMs** generating component schemas and narration

**Covers:** Visual and behavioral rules for inline Tool UIs in chat  
**Doesn't cover:** Backend pipelines, full-screen apps, multi-user collaboration (see Advanced docs)

> **Note:** This is v0.1 of Tool UI. We're focusing on single-user, single-turn interactions first. Complex workflows and deep personalization are planned for v2+.

## TL;DR

ğŸ”´ **Required** â€” Hard invariant; must pass to be a Tool UI  
ğŸŸ¡ **Default Budget** â€” Recommended constraint; bend with clear reason

- **One intent per surface** ğŸ”´
- **Inline, not destination** ğŸ”´
- **Schema-first & addressable** ğŸ”´
- **Assistant-anchored & conversation-ready** ğŸ”´
- **Lifecycle & time are explicit** ğŸ”´
- **Effects require receipts** ğŸ”´
- **Respect budgets** (3s / 3 choices / 2 levels) ğŸŸ¡
- **Accessibility floor** ğŸ”´

## Quick Examples

These examples are here to ground the guidelines in something concrete. Full docs live on each component page.

### Option List (Decision Role)

Inline single- or multi-select with confirm/clear:

```tsx
import { OptionList } from "@tool-ui/option-list";

<OptionList
  options={[
    { id: "approve", label: "Approve" },
    { id: "reject", label: "Reject" },
  ]}
  selectionMode="single"
  confirmLabel="Continue"
/>
```

- **Intent:** "Pick an option and confirm"  
- **Role:** decision  
- **Lifecycle:** invocation â†’ interactive â†’ receipt

### Media Card (Information Role)

Inline link/media preview:

```tsx
import { MediaCard } from "@tool-ui/media-card";

<MediaCard
  id="link-preview-1"
  kind="link"
  href="https://example.com"
  title="Example Site"
  description="A preview of the linked content"
/>
```

- **Intent:** "Preview this link with rich metadata"  
- **Role:** information  
- **Lifecycle:** invocation â†’ output-pending â†’ interactive

### Data Table (Information Role, Often Composite)

Tabular results with actions:

```tsx
import { DataTable } from "@tool-ui/data-table";

<DataTable
  rowIdKey="id"
  columns={[
    { key: "name", label: "Name", priority: "primary" },
    { key: "price", label: "Price" },
  ]}
  data={[
    { id: "1", name: "Basic Plan", price: "$10" },
    { id: "2", name: "Pro Plan", price: "$20" },
  ]}
/>
```

- **Intent:** "Show structured tool outputs in a scannable way"  
- **Role:** information (often "information with control" when row actions are added)  
- **Lifecycle:** invocation â†’ loading â†’ interactive â†’ stale/superseded

## The 5 Fundamentals

### 1. One Intent per Surface

Each Tool UI instance has one primary outcome and a declared role.

If a surface enables two unrelated outcomes, split it. A table that filters, exports, emails, and schedules is four surfaces, not one.

**Example:** Render search results separately from filtering controls. Show the table first, then offer filters as a distinct Tool UI if needed.

### 2. Inline, Not Destination

Tool UIs live inside messages, optimized for chat width and scroll context.

No fullscreen takeovers, no nested navigation, no mini-apps. Tool UIs support the conversation. They don't replace it. Richer views should be explicit user choices ("Open in app"), not automatic behaviors.

### 3. Schema-First, Conversation-Ready

Tool UIs render from JSON that matches a published schema. The schema includes:
- Stable IDs for the surface and addressable children
- Actions with canonical sentences
- Timestamps for temporal awareness

This enables the assistant to reference (*"the table above"*), interpret actions (*"Sort by price"*), and track freshness (*"As of 2:41 PM"*).

### 4. Assistant-Anchored Collaboration

The assistant introduces, interprets, and closes every Tool UI. It never "just appears."

**Narration patterns:**
- **Before:** Set context â†’ *"Found 12 matching PRs, highlighting urgent ones"*
- **During:** Explain transitions â†’ *"Filtered to high-priority items"*
- **After:** Summarize outcomes â†’ *"Approved and merged to main branch"*

### 5. Temporal & Lifecycle Awareness

Tool UIs move through explicit phases: invocation â†’ loading â†’ interactive â†’ commit â†’ receipt.

Data freshness is honest (*"As of 2:41 PM"*), staleness is visible, and side effects always end in durable receipts. Old surfaces are marked historical or superseded, never silently wrong.

## Roles & Patterns

Every Tool UI has a primary role defining why it exists.

### Information
**Purpose:** Structure tool output for understanding  
**Examples:** MediaCard, DataTable, CodeDiff  
**Patterns:** 
- Prioritize decision-enabling fields
- Default to glanceable with progressive detail
- Use visual encoding (badges, colors) to reduce load

### Decision  
**Purpose:** Capture user choice  
**Examples:** OptionList, SingleChoice, MultiSelect  
**Patterns:**
- One visually dominant primary action
- Two-step confirmation for destructive actions
- Must reach receipt state after commit

### Control
**Purpose:** Adjust tool or assistant behavior  
**Examples:** FilterStrip, ParameterChips, DateRange  
**Patterns:**
- Safe defaults with clear current state
- Opinionated controls (chips/presets) over raw inputs
- Cheap to apply, easy to revert

### State
**Purpose:** Show tool and assistant activity  
**Examples:** ProgressTimeline, ErrorPanel, ExecutionLog  
**Patterns:**
- Visible but not overwhelming
- Include debugging detail (tool, inputs, errors)
- Update state for long operations

### Composite
**Purpose:** Primary role with secondary support  
**Examples:** DataTable with row actions (Information with Control)  
**Rules:**
- Name primary role first
- Secondary must serve the primary
- Describable as "X with Y"

## Enforceable Invariants

### Core Contract ğŸ”´

- **Single outcome & declared role**: One intent, one of the 5 roles
- **Serializable from schema alone**: No hidden client-only state
- **Stable IDs**: Surface and key children are addressable

### Conversation Requirements ğŸ”´

- **Actions carry canonical sentences**: Every button/control maps to natural language
- **Receipts for side effects**: Durable, timestamped, referenceable
- **Temporal honesty**: Show `asOf` timestamps and staleness

### Quality Floor ğŸ”´

- **Accessibility baseline**: Keyboard, labels, AA contrast
- **No layout thrash**: Outer bounds stable during streaming
- **Errors as surfaces**: Not toasts that vanish

## Lifecycle Model

Tool UIs follow predictable phases:

### States

1. **Invocation** â†’ Shell appears, intent clear
2. **Output-pending** â†’ Skeleton matches eventual layout
3. **Interactive** â†’ User can act
4. **Committing** â†’ Progress for side effects
5. **Receipt** â†’ Durable summary
6. **Errored** â†’ Actionable error surface

### Temporal Overlays

| State | Visual | Assistant Says |
|-------|--------|----------------|
| **Fresh** | Full color | "Here's the latest..." |
| **Active** | Glow border | (co-narrates actions) |
| **Stale** | â° "As of 2:41 PM" | "This is 20 min old. Refresh?" |
| **Historical** | Collapsed | "As we discussed earlier..." |
| **Superseded** | â†“ "Updated below" | "I've updated this with..." |

**Update Strategy:**
- Minor recent changes â†’ update in place
- Major changes or time gap â†’ new surface, mark old superseded

## Schema Contract

Every Tool UI schema includes:

```typescript
{
  id: string;                    // stable across turns
  role: Role;                    // information|decision|control|state|composite
  asOf?: string;                 // ISO timestamp for freshness
  actions?: Array<{
    id: string;
    label: string;
    sentence: string;            // "Approve PR #42"
  }>;
  receipt?: {
    outcome: "success"|"partial"|"failed"|"cancelled";
    summary: string;
    at: string;
  };
}
```

Full specification: [UI Specification â†’ Base Schema](./ui-specification)

## Conversation Coherence

### The Triadic Loop

<div className="not-prose">
  <div className="flex flex-col items-center space-y-4 p-6">
    <div className="text-center">
      <div className="text-lg font-semibold">User</div>
    </div>
    <div className="flex items-center space-x-8">
      <div className="text-sm">â†• Natural Language</div>
      <div className="text-sm">Direct Click â†˜</div>
    </div>
    <div className="flex items-center space-x-12">
      <div className="text-center">
        <div className="text-lg font-semibold">Assistant</div>
        <div className="text-sm text-muted-foreground">(narrator)</div>
      </div>
      <div className="text-sm">â†” Schema</div>
      <div className="text-center">
        <div className="text-lg font-semibold">Tool UI</div>
        <div className="text-sm text-muted-foreground">(renderer)</div>
      </div>
    </div>
  </div>
</div>

The assistant is the only interpreter. The UI never "speaks" silently. This is new: traditional UIs communicate directly with users. Tool UIs always have an interpreter.

### Conversational Equivalence

Every important UI action â†” one clear canonical sentence:

| UI Action | Canonical Sentence | User Says | Assistant Confirms |
|-----------|-------------------|------------|-------------------|
| Click "Approve" | "Approve PR #42" | "yes, approve it" | "Approved PR #42" |
| Select rows 2-4 | "Select items 2 through 4" | "just those three" | "Selected 3 items" |
| Filter to "West" | "Filter to Region = West" | "only show west" | "Filtered to West region" |

### Referencing & Editing

Stable IDs + ordering enable natural references:
- *"the card above"* (spatial)
- *"the second row"* (ordinal)  
- *"the Enterprise plan"* (content)

**Update strategies:**
- Minor edits â†’ update in place, narrate diff
- Major changes â†’ new surface, mark previous historical

## Budgets & Quality

### Cognitive Load ğŸŸ¡

- **3-second glance** â€” Role & primary action clear
- **â‰¤3 primary choices** â€” Visible without scrolling
- **â‰¤2 disclosure levels** â€” Surface â†’ details (no deeper)

### Performance ğŸŸ¡

- **First content â‰¤300ms** â€” After stream start
- **No container resize** â€” During streaming
- **Transitions â‰¤200ms** â€” Respect reduced motion

### Density ğŸŸ¡

- **No inner scrollbars** â€” Let chat handle scrolling
- **"View more" pattern** â€” For large content

## Accessibility & Responsiveness

### Required Floor ğŸ”´

- **Keyboard** â€” Everything reachable, logical tab order
- **Screen readers** â€” Roles, labels, state changes announced
- **Visual** â€” AA contrast, 44px minimum touch targets
- **Mobile-first** â€” Works at 320px, scales up gracefully

## Anti-Patterns

### Ban List

- **Form-in-chat** â€” Multi-field forms pretending to be Tool UIs
- **Hidden side effects** â€” Mutations without receipts
- **Kitchen-sink surfaces** â€” Dashboards in messages
- **Layout jump** â€” Container bounds changing mid-stream
- **Tool UI as destination** â€” Navigation flows inside messages

If you're building any of these, stop and redesign.

## For Radix/shadcn Users

Tool UI complements your existing primitives:

```tsx
// Radix/shadcn (what you know)
<Dialog open={open} onOpenChange={setOpen}>
  <Button variant="destructive">Delete</Button>
</Dialog>

// Tool UI (what we add)
<Decision
  id="delete-decision"
  role="decision"
  actions={[
    { 
      id: "delete", 
      sentence: "Delete this file",
      variant: "destructive" 
    }
  ]}
  receipt={{
    outcome: "success",
    summary: "File deleted"
  }}
/>
```

**What Tool UI adds:**
- Schema layer for LLM integration
- Stable IDs for conversation
- Canonical sentences for actions
- Lifecycle and temporal behavior
- Receipt patterns

You still use Radix/shadcn under the hoodâ€”Tool UI makes them conversation-native.

## Design Checklist

### Core Design ğŸ”´
- [ ] **One-sentence intent**: Can you describe it in one sentence?
- [ ] **Primary role declared**: Information, Decision, Control, State, or Composite?
- [ ] **Lifecycle phases**: Which ones? What triggers transitions?
- [ ] **Receipts for effects**: Any side effects produce durable receipts?

### Conversation ğŸ”´
- [ ] **Schema-driven**: Fully reconstructable from schema alone?
- [ ] **Stable IDs**: Surface and key elements addressable?
- [ ] **Canonical sentences**: Every action has natural language?
- [ ] **Temporal honesty**: Shows "As of" and staleness?

### Quality ğŸŸ¡
- [ ] **Cognitive budget**: 3s glance, â‰¤3 choices, â‰¤2 levels?
- [ ] **Performance**: First content fast, no layout thrash?
- [ ] **Accessibility**: Keyboard, labels, contrast all good?
- [ ] **Responsive**: Works mobile-first?

If a Tool UI fails multiple checks, simplify, split, or redesign.

## Next Steps

- [**Quick Start**](./quick-start): Build your first Tool UI
- [**Components**](./gallery): Explore what's available
- [**Contributing**](./contributing): Build new components
