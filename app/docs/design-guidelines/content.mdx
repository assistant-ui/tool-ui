import { DocsHeader } from "../_components/docs-header";

<DocsHeader title="UI Guidelines" />

Design principles and interaction patterns for Tool UIs.

## The Collaboration Model

Traditional UI is two-party: **User ↔ Interface**. Tool UI introduces a third participant.

```
              User
             ↙    ↘
       controls    observes
           ↓          ↓
      Surface ←————→ Assistant
             mediates
```

The assistant isn't just generating UI—it contextualizes, interprets, and narrates. The surface isn't a standalone widget—it's one half of a presentation that only makes sense with the assistant's words around it.

### Division of Labor

| Capability | Surface | Assistant |
|------------|---------|-----------|
| Display structured data | ✓ | |
| Enable precise interaction | ✓ | |
| Provide context and explanation | | ✓ |
| Reference conversation history | | ✓ |
| Execute side effects | ✓ (triggers) | ✓ (initiates) |

**Key insight:** Surfaces and assistants are complementary. Don't make surfaces explain themselves (that's narration). Don't make assistants render complex data inline (that's what surfaces are for).


## Core Principles

### One Intent per Surface

Each surface answers one question. Secondary interactions may support that intent but must not compete with it.

| Level | Definition | Example |
|-------|------------|---------|
| **Atom** | Single role, single action | Confirmation prompt |
| **Molecule** | Primary role + supporting interactions | Table with row actions |
| **Organism** | Multiple competing intents | Avoid—split it up |

**The test:** If you removed the secondary interactions, would the surface still make sense?

- DataTable without row actions? Still useful. ✓ Molecule
- OptionList without confirm button? Useless. ✓ Atom (button is essential)
- Dashboard with charts AND filters AND actions? Split it. ✗ Organism

### Inline, Not Destination

Surfaces live inside messages, supporting the current turn without becoming separate destinations.

Keep users in the conversation. Richer views should be explicit actions, not defaults.

### Assistant-Anchored

The assistant introduces, interprets, and follows up on every surface. Each surface is a collaboration: the UI provides structure, the assistant provides context.

**Narration phases:**

| Phase | Purpose | When |
|-------|---------|------|
| **Introduction** | Set context before surface appears | Always |
| **Annotation** | Explain patterns, anomalies | When helpful |
| **Guidance** | Suggest actions for decisions | For Decision surfaces |
| **Summary** | Recap outcomes | After side effects |

### Schema-Driven

Surfaces render from structured JSON matching a schema. The schema is the contract, the UI its expression.

**Schema requirements:**

- **Complete:** Include all data for rendering and state restoration
- **Semantic:** Machine-readable labels that translate to natural language
- **Temporal:** Add `asOf` timestamps for staleness detection

### Receipts for Side Effects

Any action changing something outside the conversation must produce a receipt.

```typescript
interface Receipt {
  outcome: "success" | "partial" | "failed" | "cancelled";
  summary: string;
  identifiers?: Record<string, string>;
  at: string; // ISO timestamp
}
```

Receipts are proof—they let users verify, assistants reference, and provide audit trails.


## Design Laws

Physical and cognitive constraints for embedded UIs.

### Law 1: Vertical Budget

Communicate purpose within **300px of vertical space**.

| Zone | Content |
|------|---------|
| First 300px | Primary value—what it shows, what user can do |
| Beyond 300px | Progressive detail, expanded content |
| Maximum | ~600px before requiring scroll/pagination |

### Law 2: Width Tax

Every horizontal element competes for 400-600px of space.

| Pattern | Viability |
|---------|-----------|
| Single column | Preferred |
| Two columns | OK for key-value pairs |
| Three+ columns | Tables only, with scroll fallback |
| Inline form fields | Avoid; stack vertically |

### Law 3: Touch Targets

Minimum **44×44px** for all interactive elements.

| Element | Minimum | Recommended |
|---------|---------|-------------|
| Buttons | 44×44px | 44×48px |
| Icon buttons | 44×44px | 48×48px |
| List items | 44px height | 48-56px height |

### Law 4: Choice Limits

Limit visible choices aggressively. The assistant handles overflow.

| Context | Maximum |
|---------|---------|
| Primary actions | 2-3 |
| Option list items | 5-7 |
| Table rows (initial) | 5-7 |
| Filter options | 4-6 |

### Law 5: Feedback Timing

| Duration | Required Feedback |
|----------|-------------------|
| < 100ms | State change (press, selection) |
| 100ms - 1s | Loading indicator |
| 1s - 10s | Progress indicator + status |
| > 10s | Progress bar + cancel option |

### Law 6: Safety Friction

Match friction to consequence:

| Action Type | Friction |
|-------------|----------|
| Read-only | None |
| Reversible | None |
| Irreversible, low-stakes | Confirmation step |
| Irreversible, high-stakes | Two-step + summary |


## Lifecycle

Surfaces follow a predictable lifecycle. Components may skip phases.

### Pending

Initial shell, awaiting data.

- Show skeleton matching eventual layout
- Maintain visual stability as data loads
- First frame should reveal intent

### Ready

Data loaded, surface interactive.

- User can view and act
- Visually indicate uncommitted selections
- Gate actions until requirements met

### Committing

User action in progress.

- Show progress on triggered action
- Display scope of what's affected
- Show destination for side effects

### Committed

Action complete, surface settled.

- Show receipt with outcome
- Controls become disabled (Static mode)
- Remains referenceable by assistant

### Stale

Data may be outdated.

- Show "As of" timestamp
- Provide refresh option
- Visual de-emphasis


## Roles

Every surface has a primary role. Name it first.

### Information

Display data for understanding.

**Examples:** Tables, lists, metric summaries, code diffs, media previews

**Guidelines:**
- Prioritize decision-enabling fields
- Use visual encoding (badges, deltas) to reduce cognitive load
- Default to glanceable views with progressive detail

### Decision

Capture user choice.

**Examples:** Approval prompts, send/discard dialogs, multi-select actions

**Guidelines:**
- One visually dominant primary action
- Two-step confirmation for destructive actions
- Replace controls with receipts after completion

### Control

Adjust parameters.

**Examples:** Filters, sort controls, date ranges, thresholds

**Guidelines:**
- Safe defaults with clear current state
- Opinionated controls (chips, presets) over raw inputs
- Cheap to apply, easy to revert

### State

Show activity and progress.

**Examples:** Progress indicators, tool call timelines, activity logs

**Guidelines:**
- Visible but not overwhelming
- Update during long operations
- Debugging detail for tool calls


## Conversation Coherence

### Every Action Has a Sentence

Important actions must be expressible as natural language:

| Button | Sentence |
|--------|----------|
| "Confirm" | "Yes, go ahead" |
| "Filter to errors" | "Only show errors" |
| ↻ (refresh) | "Refresh this" |

If the assistant can't describe an action, the UI is too opaque.

### Surfaces are Referenceable

Enable pointing at specific elements:

- *"Sort the table above by price"*
- *"Remove the second option"*
- *"Explain the third row"*

**Requirements:**
- Stable surface identity in transcript
- Stable element identifiers
- Ambiguous references resolve to most recent surface

### Supersession

When a new surface replaces an older one:

1. Old surface becomes visually de-emphasized
2. Old surface becomes Static (actions disabled)
3. Old surface shows "Updated below" indicator
4. Old surface remains in scroll history


## Design Checklist

### Identity
- [ ] Role declared (Information, Decision, Control, State)?
- [ ] Primary intent clear?
- [ ] If composite, primary role dominates?

### Lifecycle
- [ ] Phases mapped?
- [ ] Transitions defined?
- [ ] Staleness handled?

### Constraints
- [ ] Primary value in first 300px?
- [ ] Works in 400-600px width?
- [ ] Touch targets 44px+?
- [ ] Choices limited to 5-7?

### Narration
- [ ] Assistant can introduce it?
- [ ] Assistant can add insight?
- [ ] Assistant can reference it later?

### Actions
- [ ] Every action speakable?
- [ ] Friction matches stakes?
- [ ] Side effects produce receipts?

### Accessibility
- [ ] Full keyboard navigation?
- [ ] Screen reader support?
- [ ] 4.5:1 contrast minimum?
- [ ] Respects prefers-reduced-motion?

### Schema
- [ ] Zod schema defined?
- [ ] Runtime props (callbacks) separated?
- [ ] Parser function exported?


## Component Library

Surfaces must use shadcn/ui wrappers from `components/ui/*` for consistent styling and accessibility.

### Allowed primitives

`Button`, `Card`, `Dialog`, `DropdownMenu`, `Input`, `Label`, `Select`, `Skeleton`, `Table`, `Tooltip`, `Badge`, `Avatar`, `Accordion`

> Need a new primitive? Add the shadcn wrapper under `components/ui/` first.
