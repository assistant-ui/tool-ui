import { DocsHeader } from "../_components/docs-header";
import { MockThread, MockMessage } from "../_components/mock-thread";
import { DataTable } from "@/components/tool-ui/data-table";

<DocsHeader title="UI Guidelines" mdxPath="app/docs/design-guidelines/content.mdx" />

Core principles for building conversation-native Tool UIs.

## The Collaboration Model

In AI chat, users interact with both the assistant and any UI surfaces it renders. Most tool UIs treat this as incidental. We treat it as foundational.

<Mermaid chart={`
flowchart LR
    U(("  User  "))
    S["Surface"]
    A(("Assistant"))

    U -- controls --> S
    U -. observes .-> S
    S <-- mediates --> A
    A -. narrates .-> U

    style U fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    style S fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style A fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff

    linkStyle 0 stroke:#3b82f6,stroke-width:2px
    linkStyle 1 stroke:#3b82f6,stroke-width:1px
    linkStyle 2 stroke:#10b981,stroke-width:2px
    linkStyle 3 stroke:#8b5cf6,stroke-width:1px

`} />

The assistant contextualizes, interprets, and narrates. The surface provides structure the assistant can't match inline: interactive data, precise controls, rich media. They're complementary, each handling what the other does poorly.

### Division of Labor

<table>
  <thead>
    <tr>
      <th>Capability</th>
      <th>Surface</th>
      <th>Assistant</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Display structured data</td>
      <td>✓</td>
      <td></td>
    </tr>
    <tr>
      <td>Enable precise interaction</td>
      <td>✓</td>
      <td></td>
    </tr>
    <tr>
      <td>Provide context and explanation</td>
      <td></td>
      <td>✓</td>
    </tr>
    <tr>
      <td>Reference conversation history</td>
      <td></td>
      <td>✓</td>
    </tr>
    <tr>
      <td>Execute side effects</td>
      <td>✓ (triggers)</td>
      <td>✓ (initiates)</td>
    </tr>
  </tbody>
</table>

<MockThread caption="The triadic loop in action">
  <MockMessage role="user">
    <p className="text-sm">Find auth libraries for React</p>
  </MockMessage>
  <MockMessage role="assistant">
    <p className="text-foreground">
      Found 8 repositories matching "auth". The top results by recent activity:
    </p>
    <div className="mt-3">
      <DataTable
        rowIdKey="id"
        columns={[
          { key: "name", label: "Repository", priority: "primary" },
          {
            key: "stars",
            label: "Stars",
            align: "right",
            format: { kind: "number" },
          },
          {
            key: "updated",
            label: "Last Commit",
            format: { kind: "date", dateFormat: "relative" },
          },
        ]}
        data={[
          {
            id: "1",
            name: "next-auth",
            stars: 19420,
            updated: "2025-01-18T10:00:00Z",
          },
          {
            id: "2",
            name: "passport",
            stars: 847,
            updated: "2025-01-15T14:30:00Z",
          },
          {
            id: "3",
            name: "auth0-react",
            stars: 3210,
            updated: "2025-01-12T09:00:00Z",
          },
          {
            id: "4",
            name: "firebase-auth",
            stars: 562,
            updated: "2025-01-10T16:45:00Z",
          },
          {
            id: "5",
            name: "clerk-sdk",
            stars: 1580,
            updated: "2025-01-08T11:20:00Z",
          },
        ]}
      />
    </div>
  </MockMessage>
  <MockMessage role="user">
    <p className="text-sm">Which one would you recommend for a Next.js app?</p>
  </MockMessage>
  <MockMessage role="assistant">
    <p className="text-foreground">
      I recommend <strong>next-auth</strong>. It's purpose-built for Next.js,
      has by far the most stars, and was updated most recently. Want me to show
      you setup instructions?
    </p>
  </MockMessage>
</MockThread>

The assistant introduces the surface, the user scans it and asks a follow-up, and the assistant answers by referencing specific rows. The conversation is collaborative: user, surface, and assistant each contribute what the others can't.

## Fundamentals

### One Intent per Surface

Each instance does one primary job. A table that filters, exports, and schedules is three surfaces, not one.

<table>
  <thead>
    <tr>
      <th>Level</th>
      <th>Definition</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <strong>Atom</strong>
      </td>
      <td>Single role, single action</td>
      <td>Confirmation prompt</td>
    </tr>
    <tr>
      <td>
        <strong>Molecule</strong>
      </td>
      <td>Primary role + supporting interactions</td>
      <td>Table with row actions</td>
    </tr>
    <tr>
      <td>
        <strong>Organism</strong>
      </td>
      <td>Multiple competing intents</td>
      <td>Avoid - split it up</td>
    </tr>
  </tbody>
</table>

### Schema-First & Addressable

Components render from JSON with stable IDs (surface + key children) enabling references like _"the second row"_ or _"the card above"_.

### Assistant-Anchored

The assistant narrates every Tool UI:

<table>
  <thead>
    <tr>
      <th>Phase</th>
      <th>Purpose</th>
      <th>When</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <strong>Introduction</strong>
      </td>
      <td>Set context before surface appears</td>
      <td>Always</td>
    </tr>
    <tr>
      <td>
        <strong>Annotation</strong>
      </td>
      <td>Explain patterns, anomalies</td>
      <td>When helpful</td>
    </tr>
    <tr>
      <td>
        <strong>Guidance</strong>
      </td>
      <td>Suggest actions for decisions</td>
      <td>For Decision surfaces</td>
    </tr>
    <tr>
      <td>
        <strong>Summary</strong>
      </td>
      <td>Recap outcomes</td>
      <td>After side effects</td>
    </tr>
  </tbody>
</table>

### Temporal & Lifecycle Aware

Surfaces move through explicit phases and show honest timestamps.

**Lifecycle:** Pending → Ready → Committing → Committed → Stale

**Supersession:** When data changes significantly, create a new surface and mark the old one superseded rather than silently updating.

## Roles

Every Tool UI declares its primary role:

<table>
  <thead>
    <tr>
      <th>Role</th>
      <th>Purpose</th>
      <th>Examples</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <strong>Information</strong>
      </td>
      <td>Display data</td>
      <td>DataTable, MediaCard</td>
    </tr>
    <tr>
      <td>
        <strong>Decision</strong>
      </td>
      <td>Capture consequential choices with receipts</td>
      <td>Approve/reject, send/cancel</td>
    </tr>
    <tr>
      <td>
        <strong>Control</strong>
      </td>
      <td>Adjust parameters without commitment</td>
      <td>Filters, sort, date ranges</td>
    </tr>
    <tr>
      <td>
        <strong>State</strong>
      </td>
      <td>Expose internal activity</td>
      <td>Progress indicators, logs</td>
    </tr>
  </tbody>
</table>

**Composite:** Primary + secondary (e.g., "information with control"). The primary role must dominate.

## Design Laws

Physical and cognitive constraints for embedded UIs.

### Vertical Budget

Communicate purpose within **300px**. Maximum ~600px before requiring scroll/pagination.

### Width Tax

Everything competes for 400-600px. Prefer single column. Two columns OK for key-value. Three+ only for tables with scroll fallback.

### Touch Targets

Minimum **44×44px** for all interactive elements.

### Choice Limits

<table>
  <thead>
    <tr>
      <th>Context</th>
      <th>Maximum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Primary actions</td>
      <td>2-3</td>
    </tr>
    <tr>
      <td>Option list items</td>
      <td>5-7</td>
    </tr>
    <tr>
      <td>Table rows (initial)</td>
      <td>5-7</td>
    </tr>
  </tbody>
</table>

The assistant handles overflow.

### Feedback Timing

<table>
  <thead>
    <tr>
      <th>Duration</th>
      <th>Required Feedback</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>&lt; 100ms</td>
      <td>State change (press, selection)</td>
    </tr>
    <tr>
      <td>100ms - 1s</td>
      <td>Loading indicator</td>
    </tr>
    <tr>
      <td>1s - 10s</td>
      <td>Progress indicator + status</td>
    </tr>
    <tr>
      <td>&gt; 10s</td>
      <td>Progress bar + cancel option</td>
    </tr>
  </tbody>
</table>

### Safety Friction

Match friction to consequence:

<table>
  <thead>
    <tr>
      <th>Action Type</th>
      <th>Friction</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Read-only / Reversible</td>
      <td>None</td>
    </tr>
    <tr>
      <td>Irreversible, low-stakes</td>
      <td>Confirmation step</td>
    </tr>
    <tr>
      <td>Irreversible, high-stakes</td>
      <td>Two-step + summary</td>
    </tr>
  </tbody>
</table>

## Required Invariants

### Core Contract

- Single outcome & declared role
- Fully serializable from schema (JSON-safe, reconstructable)
- Stable IDs for surface and key children

### Conversation Requirements

- Every important action maps to a **canonical sentence**
- Side effects produce **durable receipts** (outcome, summary, identifiers, timestamp)
- **Temporal honesty** (show `asOf` and staleness/supersession behavior)

### Quality Floor

- Keyboard navigable, screen-reader friendly, 4.5:1 contrast minimum
- **No layout thrash during streaming** (skeleton matches final layout)
- Errors as **first-class surfaces**, not toasts

## Conversation Coherence

Every UI action has a natural language equivalent:

<table>
  <thead>
    <tr>
      <th>Button</th>
      <th>Sentence</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>"Confirm"</td>
      <td>"Yes, go ahead"</td>
    </tr>
    <tr>
      <td>"Filter to errors"</td>
      <td>"Only show errors"</td>
    </tr>
    <tr>
      <td>↻ (refresh)</td>
      <td>"Refresh this"</td>
    </tr>
  </tbody>
</table>

If the assistant can't describe an action, the UI is too opaque.

**The Triadic Loop:** User ⇄ Assistant ⇄ Surface. The assistant interprets all interactions.

## Receipts

Any action with side effects must produce a receipt:

```typescript
interface Receipt {
  outcome: "success" | "partial" | "failed" | "cancelled";
  summary: string;
  identifiers?: Record<string, string>;
  at: string; // ISO timestamp
}
```

Receipts provide proof. They let users verify outcomes, assistants reference past actions, and serve as audit trails.

## Anti-Patterns

- **Forms in chat:** Multi-field forms pretending to be Tool UIs
- **Hidden mutations:** Side effects without receipts
- **Kitchen sinks:** Dashboards crammed into messages
- **Mini-apps:** Navigation flows inside Tool UIs
- **Silent surfaces:** No assistant introduction
- **Redundant narration:** Assistant describes exactly what surface shows

## Design Checklist

### Identity

- Role declared (Information, Decision, Control, State)
- Primary intent is clear
- If composite, primary role dominates

### Constraints

- Primary value in first 300px
- Works in 400-600px width
- Touch targets 44px minimum
- Choices limited to 5-7

### Narration

- Assistant can introduce it
- Assistant can add insight (not just repeat data)
- Assistant can reference it later

### Actions

- Every action is speakable
- Friction matches stakes
- Side effects produce receipts

### Schema

- Zod schema defined
- Runtime props (callbacks) separated
- Stable IDs for surface and children
