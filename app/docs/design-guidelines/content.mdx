import { DocsHeader } from "../_components/docs-header";
import { MockThread, MockMessage } from "../_components/mock-thread";
import { CollaborationDiagram } from "../_components/collaboration-diagram";
import { DataTable } from "@/components/tool-ui/data-table";
import { OptionList } from "@/components/tool-ui/option-list";

<DocsHeader
  title="Design Guidelines"
  description="Principles for agentic UI. A work in progress."
  mdxPath="app/docs/design-guidelines/content.mdx"
/>

## The Collaboration Model

In AI chat, users interact with both the assistant and any tool UIs it renders. Most tool UIs treat this relationship as incidental: a tool UI appears, the user clicks something, done. We treat it as foundational. The assistant, the tool UI, and the user form a collaborative triad.

<CollaborationDiagram />

The assistant contextualizes, interprets, and narrates. The tool UI provides structure that prose cannot: sortable tables, precise controls, rich media. Neither replaces the other.

<div className="mx-auto max-w-2xl">
  <MockThread caption="The triadic loop in action">
    <MockMessage role="user">
      <span className="text-sm">find a good auth library for React</span>
    </MockMessage>
    <MockMessage role="assistant">
      <span className="text-foreground">
        Found 8 React auth libraries on GitHub. Here are the top results by
        recent activity:
      </span>
      <div className="mt-3">
        <DataTable
          rowIdKey="id"
          columns={[
            {
              key: "name",
              label: "Repository",
              priority: "primary",
              format: { kind: "link", hrefKey: "url", external: true },
            },
            {
              key: "stars",
              label: "Stars",
              align: "right",
              format: { kind: "number" },
            },
            {
              key: "weeklyChange",
              label: "Weekly",
              align: "right",
              format: { kind: "delta", decimals: 0, showSign: true },
            },
            {
              key: "issues",
              label: "Issues",
              align: "right",
              format: { kind: "number" },
            },
            {
              key: "license",
              label: "License",
              format: { kind: "badge" },
            },
          ]}
          data={[
            {
              id: "1",
              name: "next-auth",
              url: "https://github.com/nextauthjs/next-auth",
              stars: 19420,
              weeklyChange: 342,
              issues: 86,
              license: "MIT",
            },
            {
              id: "2",
              name: "passport",
              url: "https://github.com/jaredhanson/passport",
              stars: 847,
              weeklyChange: -12,
              issues: 124,
              license: "MIT",
            },
            {
              id: "3",
              name: "auth0-react",
              url: "https://github.com/auth0/auth0-react",
              stars: 3210,
              weeklyChange: 89,
              issues: 23,
              license: "MIT",
            },
            {
              id: "4",
              name: "firebase-auth",
              url: "https://github.com/nicholasgriffintn/firebase-auth",
              stars: 562,
              weeklyChange: 8,
              issues: 45,
              license: "Apache-2.0",
            },
            {
              id: "5",
              name: "clerk-sdk",
              url: "https://github.com/clerk/javascript",
              stars: 1580,
              weeklyChange: 156,
              issues: 31,
              license: "MIT",
            },
          ]}
        />
      </div>
    </MockMessage>
    <MockMessage role="user">
      <span className="text-sm">
        Which one would you recommend for a Next.js app?
      </span>
    </MockMessage>
    <MockMessage role="assistant">
      <span className="text-foreground">
        I recommend <strong>next-auth</strong>. It's purpose-built for Next.js,
        has by far the most stars, and was updated most recently. Want me to
        show you setup instructions?
      </span>
    </MockMessage>
  </MockThread>
</div>

The assistant introduces the tool UI, the user scans it and asks a follow-up, the assistant answers by referencing specific rows. This is the triadic loop.

## Roles

Every Tool UI has a primary role:

- **Information:** Display data (tables, cards, charts). The focus is on comprehension rather than interaction.

- **Decision:** Capture consequential choices (approve/reject, send/cancel). These require clear options and receipts that prove what happened.

- **Control:** Adjust parameters without commitment (filters, sort orders, date ranges). Changes are reversible.

- **State:** Expose internal activity (progress indicators, status logs, loading states).

Some tool UIs combine roles. A data table with row actions is "information with control." When combining, the primary role should dominate.

## Constraints

Tool UIs live in chat: narrow widths, variable heights, mixed with prose.

- **Vertical:** Communicate purpose within the first 300px or so.
- **Horizontal:** Expect 400–600px. Prefer single-column layouts.
- **Touch:** Interactive elements need at least 44×44px tap area.
- **Choices:** Limit visible options to 5–7. The assistant can offer to show more.

## Addressability

If the assistant can't point at something later, you lose half the value of rendering it.

- **`id`**: Identifies this specific tool UI in the conversation ("the preview above", "that table").
- **`assetId` / row IDs / option IDs**: Identify real objects ("that link", "row 4", "the merge option").

Prefer stable IDs derived from your backend (database IDs, canonical URLs) over array indexes or UUIDs generated at render time. When something can be acted on, it should have an ID the assistant can cite.

## Receipts

When a user takes an action with consequences, the tool UI should transition to a receipt state that confirms what happened. This gives the user proof and gives the assistant something to reference later.

<div className="mx-auto max-w-2xl">
  <MockThread caption="A decision tool UI with receipt">
    <MockMessage role="assistant">
      <span className="text-foreground">
        How would you like to handle the duplicate contacts?
      </span>
      <div className="mt-3">
        <OptionList
          selectionMode="single"
          confirmed="merge"
          options={[
            {
              id: "merge",
              label: "Merge duplicates",
              description: "Combine into single contacts, keeping all data",
            },
            {
              id: "keep",
              label: "Keep all",
              description: "Leave duplicates as separate contacts",
            },
            {
              id: "review",
              label: "Review manually",
              description: "I'll decide for each duplicate",
            },
          ]}
        />
      </div>
    </MockMessage>
    <MockMessage role="assistant">
      <span className="text-foreground">
        Done. I merged 12 duplicate contacts. You can undo this from Settings →
        Contact History if needed.
      </span>
    </MockMessage>
  </MockThread>
</div>

The receipt shows what the user chose. The assistant's follow-up confirms the outcome and offers a way to reverse it.

## Anti-Patterns

- **Input fields:** Input fields introduce dissonance by competing with the primary composer input. Consider whether it would be more appropriate to capture that information through dialogue with the assistant or, in rare cases, link to a dedicated form outside of or detached from the chat context.
- **Hidden mutations:** Actions that change state should produce visible indication of what happened; terminal decisions should produce a receipt that reflects what choice the user made.
- **Kitchen sinks:** If it needs tabs or navigation, consider breaking it into separate Tool UIs.
- **Uncontextualized tool UIs:** Always have the assistant introduce a tool UI, providing context that clarifies what's being shown.
- **Redundant narration:** The assistant shouldn't describe what the tool UI already shows. Conversely, the tool UI shouldn't echo what the assistant just said. If the assistant asks "Where to?", the tool UI doesn't need a header saying "Where to?"; just show the options. Divide the work: the assistant provides context, the tool UI provides structure.
