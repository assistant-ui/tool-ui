import { DocsHeader } from "../_components/docs-header";
import { MockThread, MockMessage } from "../_components/mock-thread";
import { DataTable } from "@/components/tool-ui/data-table";
import { OptionList } from "@/components/tool-ui/option-list";

<DocsHeader
  title="Design Guidelines"
  mdxPath="app/docs/design-guidelines/content.mdx"
/>

Principles for building Tool UIs that feel native to conversation.

<span className="text-muted-foreground italic">
  These guidelines are evolving as we learn what works.
</span>

## The Collaboration Model

In AI chat, users interact with both the assistant and any UI surfaces it renders. Most tool UIs treat this relationship as incidental: a surface appears, the user clicks something, done. We treat it as foundational. The assistant, the surface, and the user form a collaborative triad.

<Mermaid chart={`
flowchart LR
    U(("  User  "))
    S["Surface"]
    A(("Assistant"))

    U -- controls --> S
    U -. observes .-> S
    S <-- mediates --> A
    A -. narrates .-> U

    style U fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    style S fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style A fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff

    linkStyle 0 stroke:#3b82f6,stroke-width:2px
    linkStyle 1 stroke:#3b82f6,stroke-width:1px
    linkStyle 2 stroke:#10b981,stroke-width:2px
    linkStyle 3 stroke:#8b5cf6,stroke-width:1px

`} />

The assistant contextualizes, interprets, and narrates. The surface provides structure that prose cannot: sortable tables, precise controls, rich media. Neither replaces the other.

<div className="mx-auto max-w-2xl">
  <MockThread caption="The triadic loop in action">
    <MockMessage role="user">
      <span className="text-sm">Find auth libraries for React</span>
    </MockMessage>
    <MockMessage role="assistant">
      <span className="text-foreground">
        Found 8 repositories matching "auth". The top results by recent
        activity:
      </span>
      <div className="mt-3">
        <DataTable
          rowIdKey="id"
          columns={[
            { key: "name", label: "Repository", priority: "primary" },
            {
              key: "stars",
              label: "Stars",
              align: "right",
              format: { kind: "number" },
            },
            {
              key: "updated",
              label: "Last Commit",
              format: { kind: "date", dateFormat: "relative" },
            },
          ]}
          data={[
            {
              id: "1",
              name: "next-auth",
              stars: 19420,
              updated: "2025-01-18T10:00:00Z",
            },
            {
              id: "2",
              name: "passport",
              stars: 847,
              updated: "2025-01-15T14:30:00Z",
            },
            {
              id: "3",
              name: "auth0-react",
              stars: 3210,
              updated: "2025-01-12T09:00:00Z",
            },
            {
              id: "4",
              name: "firebase-auth",
              stars: 562,
              updated: "2025-01-10T16:45:00Z",
            },
            {
              id: "5",
              name: "clerk-sdk",
              stars: 1580,
              updated: "2025-01-08T11:20:00Z",
            },
          ]}
        />
      </div>
    </MockMessage>
    <MockMessage role="user">
      <span className="text-sm">
        Which one would you recommend for a Next.js app?
      </span>
    </MockMessage>
    <MockMessage role="assistant">
      <span className="text-foreground">
        I recommend <strong>next-auth</strong>. It's purpose-built for Next.js,
        has by far the most stars, and was updated most recently. Want me to
        show you setup instructions?
      </span>
    </MockMessage>
  </MockThread>
</div>

The assistant introduces the surface, the user scans it and asks a follow-up, the assistant answers by referencing specific rows. This is the triadic loop.

## Roles

Every Tool UI has a primary role:

- **Information:** Display data (tables, cards, charts). The focus is on comprehension rather than interaction.

- **Decision:** Capture consequential choices (approve/reject, send/cancel). These require clear options and receipts that prove what happened.

- **Control:** Adjust parameters without commitment (filters, sort orders, date ranges). Changes are reversible.

- **State:** Expose internal activity (progress indicators, status logs, loading states).

Some surfaces combine roles. A data table with row actions is "information with control." When combining, the primary role should dominate.

## Constraints

Tool UIs live in chat: narrow widths, variable heights, mixed with prose.

- **Vertical:** Communicate purpose within the first 300px or so.
- **Horizontal:** Expect 400–600px. Prefer single-column layouts.
- **Touch:** Interactive elements need at least 44×44px tap area.
- **Choices:** Limit visible options to 5–7. The assistant can offer to show more.

## Receipts

When a user takes an action with consequences, the surface should transition to a receipt state that confirms what happened. This gives the user proof and gives the assistant something to reference later.

<div className="mx-auto max-w-2xl">
  <MockThread caption="A decision surface with receipt">
    <MockMessage role="assistant">
      <span className="text-foreground">
        How would you like to handle the duplicate contacts?
      </span>
      <div className="mt-3">
        <OptionList
          selectionMode="single"
          confirmed="merge"
          options={[
            {
              id: "merge",
              label: "Merge duplicates",
              description: "Combine into single contacts, keeping all data",
            },
            {
              id: "keep",
              label: "Keep all",
              description: "Leave duplicates as separate contacts",
            },
            {
              id: "review",
              label: "Review manually",
              description: "I'll decide for each duplicate",
            },
          ]}
        />
      </div>
    </MockMessage>
    <MockMessage role="assistant">
      <span className="text-foreground">
        Done. I merged 12 duplicate contacts. You can undo this from Settings →
        Contact History if needed.
      </span>
    </MockMessage>
  </MockThread>
</div>

The receipt shows what the user chose. The assistant's follow-up confirms the outcome and offers a way to reverse it.

## Anti-Patterns

- **Forms in chat:** Multi-field forms don't belong in Tool UIs. Collect inputs through conversation or link to a dedicated form.
- **Hidden mutations:** Actions that change state should produce visible receipts.
- **Kitchen sinks:** If it needs tabs or navigation, consider breaking it into separate Tool UIs.
- **Silent surfaces:** Always have the assistant introduce a Tool UI.
- **Redundant narration:** The assistant shouldn't just describe what the surface already shows. It's more useful to add context or insight.
