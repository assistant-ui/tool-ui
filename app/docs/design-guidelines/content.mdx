import { DocsHeader } from "../_components/docs-header";

<DocsHeader title="UI Guidelines" />

Design principles and interaction patterns for Tool UIs.

> **Note:** We're continuously expanding these guidelines with concrete examples and patterns from real usage.


## Core Principles

### One Move per Surface

Each Tool UI supports a single action: show data, capture decisions, adjust parameters, or display state.

Split multi-purpose surfaces into separate Tool UIs to keep them focused and clear.

**Example:** Render search results separately from filtering controls. Show the table first, then offer filters as needed.

### Inline, Not Destination

Tool UIs live inside messages, supporting the current turn without becoming separate destinations.

Keep users in the conversation context. Richer views should be explicit actions, not defaults.

### Assistant-Anchored

The assistant introduces, interprets, and follows up on every Tool UI.

Each Tool UI represents a collaboration: the UI provides structure, the assistant provides context and guidance.

**Narration patterns:**

- **Before:** Set context → *"Found 12 matching PRs, highlighting urgent ones"*
- **During:** Explain transitions → *"Q3 spike driven by Enterprise tier"*
- **After:** Summarize outcomes → *"Changes applied to main branch"*

### Schema-Driven

Tool UIs render from structured outputs matching a published schema. The schema is the contract, the UI its expression.

**Schema requirements:**

- **Complete:** Include all data for rendering and state restoration (labels, IDs, configs, status)
- **Semantic:** Use machine-readable labels that translate to natural language
- **Temporal:** Add timestamps for staleness detection

### Receipts for Side Effects

Any Tool UI triggering side effects (send, delete, spend, apply, call APIs) must leave a durable receipt.

**Receipts must capture:**

- **Outcome:** Success, partial, failed, or cancelled
- **Action:** What was chosen and its scope
- **Details:** IDs, counts, amounts, targets, timestamps

Permanent references and audit trail.


## Lifecycle

Tool UIs follow a predictable lifecycle. Components may skip phases.

### Invocation

Initial rendering of the Tool UI shell.

- **Clear purpose:** First frame reveals intent (*"12 matching items"*, *"Approve changes?"*)
- **Context setting:** Assistant provides context in surrounding message
- **Visual stability:** Initial frame stays stable as data loads

### Loading and Streaming

Data arrives in chunks or streams.

- **Skeleton states:** Match eventual layout structure
- **Layout stability:** Maintain consistent outer dimensions during load
- **Progressive disclosure:** Show first items quickly, add "View more" for long results

### Interactive Window

User can modify inputs, select actions, or approve changes.

- **Pending state:** Visually indicate uncommitted state
- **Input validation:** Gate actions until requirements met
- **Destructive safety:** Two-step confirmation for dangerous actions
- **Assistant collaboration:** Surface for proposing changes and highlighting options

### Commit and Side Effects

Execution of actions with external impact.

- **Scope visibility:** Show what's being affected (rows, files, accounts)
- **Target clarity:** Show destination (branch, environment, system)
- **Progress tracking:** Display steps/phases, not just spinners
- **State transition:** Move from interactive to receipt after commit

### Receipt State

Compact, permanent summary after completion.

- **Outcome display:** Success, partial, failed, or cancelled
- **Action summary:** What was chosen and what changed
- **Reference-able:** Easy for assistant to cite later (*"As shown in the merge receipt above"*)

Receipts appear as collapsed prompts or final non-interactive states.

### Stale, Retried, Superseded

Outdated or replaced Tool UIs.

- **Temporal markers:** Show when data was captured (*"As of 2:41 PM"*)
- **Refresh options:** Provide rerun capability
- **Update strategy:**
  - Simple refreshes → Update in place
  - Structural changes → Create new UI, mark old as superseded
- **Visual hierarchy:** De-emphasize superseded UIs while keeping them visible for audit


## Roles

Every Tool UI has a single role defining *why* it exists. Name the role first.

### Information Surfaces

Structure tool output for scannability.

**Examples:** Tables, lists, metric summaries, code diffs, media previews

**Guidelines:**
- Prioritize decision-enabling fields
- Use visual encoding (badges, deltas) to reduce cognitive load
- Default to glanceable views with progressive detail
- **Lifecycle:** Invocation → Loading → Interactive → Stale/Superseded

### Decision Surfaces

Request user choice.

**Examples:** Approval prompts, send/discard dialogs, multi-select actions

**Guidelines:**
- One visually dominant primary action
- Two-step confirmation for destructive actions
- Replace controls with receipts after completion
- **Must reach:** Clear committed/receipt state

### Control Surfaces

Adjust tool or assistant behavior.

**Examples:** Filters, sort controls, date ranges, thresholds, option toggles

**Guidelines:**
- Safe defaults with clear current state
- Opinionated controls (chips, presets) over raw inputs
- Cheap to apply, easy to revert
- **Longevity:** Stay interactive longer; supersede when context shifts

### State and Observability Surfaces

Show tool and assistant activity.

**Examples:** Progress indicators, tool call timelines, activity logs, error panels

**Guidelines:**
- Visible but not overwhelming
- Debugging detail (tool, inputs, errors)
- Tightly coupled to related messages
- **Long operations:** Update state, avoid endless spinners

### Composite Surfaces

Blend multiple roles.

**Examples:** Table with row actions, media preview with quick actions

**Rules:**
- Name primary role first
- Secondary roles must serve the primary
- Must be describable as "X with Y"
- Side effects require receipts


## Conversation and Tool UIs

Tool UIs and chat express the same intent through different modalities.

### Every Control Has a Sentence

Important actions must map to simple sentences:

- *"Apply only high-priority rows"*
- *"Send to selected recipients"*
- *"Filter to last 30 days"*

If the assistant can't describe an action in words, the UI is too opaque.

### Referencing Surfaces in Conversation

Enable pointing at specific UIs and elements:

- *"Sort the table above by price"*
- *"Remove the second option"*
- *"Explain changes in the third file"*

**Requirements:**
- Stable UI identity in transcript
- Stable element identifiers for runtime resolution
- Ambiguous references resolve to most recent/active surface

### Editing and Rerunning

Support iterative refinement:

**Common patterns:** Add/remove filters, adjust thresholds, update drafts

**Update strategies:**
- **Minor changes:** Update in place (*"Table now shows only active items"*)
- **Major changes:** Create new UI, reference previous (*"Updated version below"*)

Support re-invocation with different parameters.

### Assistant Narration

Assistant messages are part of the UI experience.

- **Before:** Set context → *"Found 12 results, highlighting urgent ones"*
- **During:** Narrate transitions → *"Applying approved changes"*
- **After:** Summarize outcomes → *"Table updated with your preferences"*

Clear labels, structure, and receipts enable natural narration.


## Design Checklist

Validate new Tool UIs against:

### Core Design

- [ ] **Role declaration**: Information, Decision, Control, State, or Composite?
- [ ] **Lifecycle mapping**: Which phases? What triggers transitions?
- [ ] **Receipt generation**: Side effects must produce durable receipts

### Technical Requirements

- [ ] **Schema-driven**: Fully reconstructable from schema alone
- [ ] **Conversational mapping**: Every action expressible as a sentence
- [ ] **Staleness handling**: Clear aging indicators and refresh options
- [ ] **Supersession strategy**: When to update vs. replace

If a Tool UI fails multiple items, simplify, split, or redesign.