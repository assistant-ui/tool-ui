import { CopyMarkdownButton } from "../_components/copy-markdown-button";

<div className="flex justify-between items-start">
  # Overview
  <CopyMarkdownButton />
</div>

Render interactive, accessible UI in chat from JSON tool outputs. Tool UI ships shadcn/ui-based components you can copy-paste into any Next.js or React conversation UI so tools can return serializable props instead of plain text.

## Quick start (30 seconds)

<Steps>

<Step title="Server: return serializable props">

Define your tool with a serializable schema so LLM outputs stay predictable.

```ts
import { tool } from 'ai';
import { serializableDataTableSchema } from '@/components/data-table/schema';

export const tools = {
  listProducts: tool({
    outputSchema: serializableDataTableSchema,
    async execute() {
      return {
        columns: [
          { key: 'name', label: 'Product' },
          { key: 'price', label: 'Price', format: { kind: 'currency', currency: 'USD' } },
        ],
        data: [{ id: '1', name: 'Widget', price: 29.99 }],
      };
    },
  }),
} as const;
```

</Step>

<Step title="Client: parse and render">

Check for the tool output part, parse it, and render the component.

```tsx
import { DataTable, parseSerializableDataTable } from '@/components/data-table';

if (part.type === 'tool-listProducts' && part.state === 'output-available') {
  const props = parseSerializableDataTable(part.output);
  return <DataTable rowIdKey="id" {...props} />;
}
```

</Step>

<Step title="Actions: handle clicks in your app">

Attach actions and handle them in your app so follow-up behavior stays under your control.

```tsx
<DataTable actions={[{ id: 'buy', label: 'Buy' }]} onAction={(id, row) => doSomething(id, row)} />
```

</Step>

</Steps>

More detail: [Full Quick Start](/docs/quick-start).

## Mental model

```
tool execute → JSON (validated by Zod)
        ↓
parseSerializableX → render component
        ↓
onAction → your app handles it (server/client)
```

## Choosing the right Tool UI for the job

- [Data Table](/docs/data-table) — best for scanning or comparing rows, sorting, formatting values, and attaching actions that persist across turns (collapses to cards with `priority` on mobile).
- Rich text via [Media Card](/docs/media-card) or [Decision Prompt](/docs/decision-prompt) — narrative summaries, single entities, confirmations, or approvals with primary/secondary actions.
- [Markdown table pattern](/docs/patterns) — tiny, static datasets with no sorting or actions; render inline markdown directly in chat copy.

## Responsive layout

All components respect chat widths, theme tokens, and density constraints, with [Data Table](/docs/data-table#priority) promoting high-priority columns to mobile cards, [Media Card](/docs/media-card) clamping media ratios, and [Decision Prompt](/docs/decision-prompt) stacking buttons for touch targets.

## Schema-first

Components ship with serializable Zod schemas so tools can validate outputs on the server and the UI can `parseSerializableX` before rendering. Keep the snippet tight on the overview and jump to the Quick Start for the full flow.

```ts
import { tool } from 'ai';
import { serializableMediaCardSchema } from '@/components/media-card/schema';

const tools = {
  preview: tool({
    outputSchema: serializableMediaCardSchema,
    async execute() {
      return { id: 'card-1', kind: 'link', href: 'https://example.com' };
    },
  }),
};
```

Client side:

```tsx
import { MediaCard, parseSerializableMediaCard } from '@/components/media-card';

const card = parseSerializableMediaCard(part.output);
return <MediaCard {...card} />;
```

Deep dive: [Quick Start](/docs/quick-start).

## Accessibility & compatibility

- WCAG-friendly defaults (contrast, focus rings, 44×44 targets) plus reduced-motion support; see [Accessibility](/docs/accessibility) for audits.
- Works in React 18+ and Next.js App Router; Tailwind v3.2+ or v4 tokens out of the box.
- Handles client/server action routing: components render, your app wires the `onAction` handlers and transports.
