import { CopyMarkdownButton } from "../_components/copy-markdown-button";
import { DataTable } from "@/components/data-table";
import { FormatInlineExample } from "./formatting-gallery";
import {
  NumberValue,
  CurrencyValue,
  PercentValue,
  DeltaValue,
  DateValue,
  BooleanValue,
  LinkValue,
  BadgeValue,
  StatusBadge,
  ArrayValue,
} from "@/components/data-table";

<div className="flex justify-between items-start">
  # Data Table
  <CopyMarkdownButton />
</div>

A compact, responsive data table with sorting, declarative value formatting, and row actions.

<Tabs items={["Preview", "Code"]}>
  <Tab>
    <div className="not-prose">
      <DataTable
        rowIdKey="id"
        defaultSort={{ by: "priority", direction: "asc" }}
        columns={[
          { key: "issue", label: "Issue", priority: "primary", truncate: true },
          {
            key: "priority",
            label: "Urgency",
            format: {
              kind: "status",
              statusMap: {
                high: { tone: "danger", label: "High" },
                medium: { tone: "warning", label: "Medium" },
                low: { tone: "neutral", label: "Low" },
              },
            },
          },
        ]}
        data={[
          { id: "1", issue: "Payment failing on checkout", priority: "high" },
          { id: "2", issue: "Billing UI alignment bug", priority: "medium" },
          { id: "3", issue: "Export CSV missing headers", priority: "low" },
          { id: "4", issue: "Webhook retries inconsistent", priority: "high" },
        ]}
      />
    </div>

  </Tab>
  <Tab>
    ```tsx
    import { DataTable, type Column } from "@/components/data-table";

    type Row = { id: string; issue: string; priority: "high" | "medium" | "low" };

    const columns: Column<Row>[] = [
      { key: "issue", label: "Issue", priority: "primary", truncate: true },
      { key: "priority", label: "Urgency", format: { kind: "status", statusMap: {
        high: { tone: "danger", label: "High" }, medium: { tone: "warning", label: "Medium" }, low: { tone: "neutral", label: "Low" }
      } } },
    ];

    const data: Row[] = [
      { id: "1", issue: "Payment failing on checkout", priority: "high" },
      { id: "2", issue: "Billing UI alignment bug", priority: "medium" },
      { id: "3", issue: "Export CSV missing headers", priority: "low" },
      { id: "4", issue: "Webhook retries inconsistent", priority: "high" },
    ];

    export default function Example() {
      return (
        <DataTable rowIdKey="id" columns={columns} data={data} defaultSort={{ by: "priority", direction: "asc" }} />
      );
    }
    ```
  </Tab>
</Tabs>

## Source & install

We don't have a CLI yet, so you'll manually copy and paste `components/data-table`. It should sit alongside your shadcn/ui components directory:

<Files>
  <Folder name="components" defaultOpen>
    <Folder name="ui">
      <File name="button.tsx" />
      <File name="table.tsx" />
      <File name="..." />
    </Folder>
    <Folder name="data-table" defaultOpen>
      <File name="data-table.tsx" />
      <File name="schema.ts" />
      <File name="types.ts" />
      <File name="index.tsx" />
      <File name="..." />
    </Folder>
  </Folder>
</Files>

**Download:**
- [Source on GitHub](https://github.com/assistant-ui/tool-ui/tree/main/components/data-table)
- [Quick download (ZIP)](https://download-directory.github.io/?url=https://github.com/assistant-ui/tool-ui/tree/main/components/data-table)

## Features

Short, high‑leverage features you'll use most often, with tiny examples and why they help.

### Sorting

Tri‑state sorting: none → asc → desc (click again to reset). Use controlled mode to sync with filters or the URL.
```tsx
// Uncontrolled (internal tri‑state): click header to cycle none → asc → desc → none
<DataTable columns={columns} data={data} />

// Controlled: manage sort in parent
const [sort, setSort] = useState<{ by?: keyof Row; direction?: 'asc' | 'desc' }>({});
<DataTable columns={columns} data={data} sort={sort} onSortChange={setSort} />
```

### Responsive layout

Container queries switch between table and cards; `priority` decides what stays visible on mobile headers.

> Tailwind v4 ships container queries; on v3 install the [tailwind/container-queries](https://github.com/tailwindlabs/tailwindcss-container-queries) plugin.
```tsx
// Auto (default): container queries switch between table/cards at @md
<DataTable columns={columns} data={data} />

// Force a particular layout
<DataTable layout="table" columns={columns} data={data} />
<DataTable layout="cards" columns={columns} data={data} />

// Mobile: `priority` controls card header vs. accordion details
const columns = [
  { key: 'name', label: 'Name', priority: 'primary' },
  { key: 'price', label: 'Price', priority: 'primary' },
  { key: 'category', label: 'Category', priority: 'secondary' },
  { key: 'sku', label: 'SKU', priority: 'tertiary' },
];
```

### Declarative formatting

Keep row values primitive; describe presentation in `columns[i].format`. It keeps UI consistent and LLM/tool outputs JSON‑serializable.
```tsx
// Keep data primitive; describe presentation in format
{ key: 'price', label: 'Price', format: { kind: 'currency', currency: 'USD' } }
{ key: 'homepage', label: 'Homepage', format: { kind: 'link', external: true } }
{ key: 'status', label: 'Status', format: { kind: 'badge', colorMap: { open: 'info', closed: 'success' } } }
```

### Accessibility

- Header buttons are focusable; `aria-sort` reflects state for screen readers
- A live region announces sort changes; rows and cells read with labels
- Table toggles `aria-busy` when loading so assistive tech knows data is pending

## Example Usage

<Tabs items={["Assistant UI", "AI SDK"]}>
  <Tab>
```tsx
// ============================================================
// Server: Define tool (app/api/assistant/route.ts)
// ============================================================
import { tool } from 'ai';
import { serializableDataTableSchema } from '@/components/data-table/schema';

export const tools = {
  searchProducts: tool({
    description: 'Search products and return results in a table',
    outputSchema: serializableDataTableSchema,
    async execute({ query }) {
      const results = await db.products.search(query);
      return {
        columns: [
          { key: 'name', label: 'Product', priority: 'primary' },
          { key: 'price', label: 'Price', format: { kind: 'currency', currency: 'USD' } },
          { key: 'stock', label: 'Stock', align: 'right' },
        ],
        data: results.map(p => ({ id: p.id, name: p.name, price: p.price, stock: p.stock })),
      };
    },
  }),
};

// ============================================================
// Client: Render in chat (components/MyAssistant.tsx)
// ============================================================
import { Thread } from '@assistant-ui/react';
import { DataTable, parseSerializableDataTable } from '@/components/data-table';

export function MyAssistant() {
  return (
    <Thread
      tools={{
        searchProducts: (args, result) => {
          if (!result) return null;
          const props = parseSerializableDataTable(result);
          return <DataTable rowIdKey="id" {...props} />;
        },
      }}
    />
  );
}
```
  </Tab>
  <Tab>
```tsx
// ============================================================
// Server: Define tool (app/api/chat/route.ts)
// ============================================================
import { streamText, tool } from 'ai';
import { openai } from '@ai-sdk/openai';
import { serializableDataTableSchema } from '@/components/data-table/schema';

export async function POST(req: Request) {
  const { messages } = await req.json();

  const result = streamText({
    model: openai('gpt-4o'),
    messages,
    tools: {
      searchProducts: tool({
        description: 'Search products and return results in a table',
        outputSchema: serializableDataTableSchema,
        async execute({ query }) {
          const results = await db.products.search(query);
          return {
            columns: [
              { key: 'name', label: 'Product', priority: 'primary' },
              { key: 'price', label: 'Price', format: { kind: 'currency', currency: 'USD' } },
              { key: 'stock', label: 'Stock', align: 'right' },
            ],
            data: results.map(p => ({ id: p.id, name: p.name, price: p.price, stock: p.stock })),
          };
        },
      }),
    },
  });

  return result.toDataStreamResponse();
}

// ============================================================
// Client: Render in chat (app/page.tsx)
// ============================================================
import { useChat } from '@ai-sdk/react';
import { DataTable, parseSerializableDataTable } from '@/components/data-table';

export default function Chat() {
  const { messages } = useChat({ api: '/api/chat' });

  return (
    <div>
      {messages.map((m) => (
        <div key={m.id}>
          {m.toolInvocations?.map((tool) => {
            if (tool.toolName === 'searchProducts' && tool.state === 'result') {
              const props = parseSerializableDataTable(tool.result);
              return <DataTable key={tool.toolCallId} rowIdKey="id" {...props} />;
            }
            return null;
          })}
        </div>
      ))}
    </div>
  );
}
```
  </Tab>
</Tabs>

## Props

Data Table accepts serializable rows where each row is a record of JSON primitives (`string`, `number`, `boolean`, `null`) or arrays of primitives. Do not place objects, Dates, Maps, or functions in row values—use `format` configs for presentation instead.

### Data

<TypeTable
  type={{
    columns: { description: "Column definitions", type: "Column<T>[]", required: true },
    data: { description: "Serializable rows", type: "T[]", required: true },
    rowIdKey: { description: "Stable unique key in each row", type: "keyof T" },
    locale: { description: "Intl locale for formatting", type: "string", default: '"en-US"' },
  }}
/>

### Columns

Each column in the `columns` array defines how a data field is displayed:

<TypeTable
  type={{
    key: { description: "Maps to a key in the row data", type: "keyof T", required: true },
    label: { description: "Display text for column header", type: "string", required: true },
    abbr: { description: "Abbreviated label for narrow viewports", type: "string" },
    sortable: { description: "Enable sorting for this column", type: "boolean", default: "true" },
    align: { description: "Text alignment for cells", type: "'left' | 'right' | 'center'", default: "'left'" },
    width: { description: "Fixed width (CSS value)", type: "string" },
    truncate: { description: "Truncate text with ellipsis", type: "boolean", default: "false" },
    priority: { description: "Mobile display priority (primary = always visible, secondary = expandable, tertiary = hidden)", type: "'primary' | 'secondary' | 'tertiary'" },
    hideOnMobile: { description: "Completely hide on mobile", type: "boolean", default: "false" },
    format: { description: "Formatting config for cell values (see Formatting section)", type: "FormatConfig" },
  }}
/>

### Layout

<TypeTable
  type={{
    layout: { description: "Force table/cards or auto", type: "'auto' | 'table' | 'cards'", default: "'auto'" },
    maxHeight: { description: "Scroll container height", type: "string (CSS)" },
    emptyMessage: { description: "Shown when no rows", type: "string", default: '"No data available"' },
    isLoading: { description: "Show skeletons", type: "boolean", default: "false" },
  }}
/>

### Sorting

<TypeTable
  type={{
    defaultSort: { description: "Initial sort (uncontrolled)", type: "{ by?: keyof T; direction?: 'asc' | 'desc' }" },
    sort: { description: "Controlled sort state (with onSortChange)", type: "{ by?: keyof T; direction?: 'asc' | 'desc' }" },
    onSortChange: { description: "Update controlled sort", type: "(next) => void" },
  }}
/>

### Actions

<TypeTable
  type={{
    actions: { description: "Row actions", type: "Action[]" },
    onBeforeAction: { description: "Gate actions (confirm, policy)", type: "(args) => boolean | Promise<boolean>" },
    onAction: { description: "Action click handler", type: "(id, row, ctx?) => void" },
  }}
/>

## Formatting

All visual formatting for data stays declarative via `columns[i].format`. Keep row values as primitives (strings, numbers, booleans) and describe presentation through format configs.

<TypeTable
      type={{
        number: {
          description: (
            <FormatInlineExample
              value={12345.678}
              output={<NumberValue value={12345.678} options={{ kind: 'number', decimals: 2, unit: ' ms' }} />}
            />
          ),
          type: "{ kind: 'number', decimals: 2, unit: ' ms' }",
        },
        currency: {
          description: (
            <FormatInlineExample
              value={178.25}
              output={<CurrencyValue value={178.25} options={{ kind: 'currency', currency: 'USD', decimals: 2 }} />}
            />
          ),
          type: "{ kind: 'currency', currency: 'USD', decimals: 2 }",
        },
        percent: {
          description: (
            <>
              <FormatInlineExample
                value={0.123}
                output={<PercentValue value={0.123} options={{ kind: 'percent', basis: 'fraction', decimals: 1, showSign: true }} />}
              />
              <FormatInlineExample
                value={1.23}
                output={<PercentValue value={1.23} options={{ kind: 'percent', basis: 'unit', decimals: 2, showSign: true }} />}
              />
            </>
          ),
          type: "{ kind: 'percent', basis: 'fraction' | 'unit', decimals?: number, showSign?: boolean }",
        },
        delta: {
          description: (
            <>
              <FormatInlineExample
                value={2.35}
                output={<DeltaValue value={2.35} options={{ kind: 'delta', decimals: 2, upIsPositive: true, showSign: true }} />}
              />
              <FormatInlineExample
                value={-1.2}
                output={<DeltaValue value={-1.2} options={{ kind: 'delta', decimals: 2, upIsPositive: true, showSign: true }} />}
              />
            </>
          ),
          type: "{ kind: 'delta', decimals?: number, upIsPositive?: boolean, showSign?: boolean }",
        },
        date: {
          description: (
            <>
              <FormatInlineExample
                value={'2025-01-05T12:00:00Z'}
                output={<DateValue value={'2025-01-05T12:00:00Z'} options={{ kind: 'date', dateFormat: 'relative' }} />}
              />
              <FormatInlineExample
                value={'2025-01-05T12:00:00Z'}
                output={<DateValue value={'2025-01-05T12:00:00Z'} options={{ kind: 'date', dateFormat: 'long' }} locale="de-DE" />}
                note="Long date with locale"
              />
            </>
          ),
          type: "{ kind: 'date', dateFormat?: 'short' | 'long' | 'relative' }",
        },
        boolean: {
          description: (
            <FormatInlineExample
              value={true}
              output={<BooleanValue value={true} options={{ kind: 'boolean', labels: { true: 'Yes', false: 'No' } }} />}
            />
          ),
          type: "{ kind: 'boolean', labels?: { true: string; false: string } }",
        },
        link: {
          description: (
            <>
              <FormatInlineExample
                value={'Docs Portal'}
                output={<LinkValue value={'Docs Portal'} row={{ url: '/docs' }} options={{ kind: 'link', hrefKey: 'url' }} />}
              />
              <FormatInlineExample
                value={'https://example.com'}
                output={<LinkValue value={'https://example.com'} options={{ kind: 'link', external: true }} />}
              />
            </>
          ),
          type: "{ kind: 'link', hrefKey?: string, external?: boolean }",
        },
        badge: {
          description: (
            <FormatInlineExample
              value={'open'}
              output={<BadgeValue value={'open'} options={{ kind: 'badge', colorMap: { open: 'info', closed: 'success' } }} />}
            />
          ),
          type: "{ kind: 'badge', colorMap?: Record<string, Tone> }",
        },
        status: {
          description: (
            <FormatInlineExample
              value={'high'}
              output={<StatusBadge value={'high'} options={{ kind: 'status', statusMap: { high: { tone: 'danger', label: 'High' }, low: { tone: 'neutral', label: 'Low' } } }} />}
            />
          ),
          type: "{ kind: 'status', statusMap: Record<string, { tone: Tone; label?: string }> }",
        },
        array: {
          description: (
            <FormatInlineExample
              value={['alpha','beta','gamma']}
              output={<ArrayValue value={['alpha','beta','gamma']} options={{ kind: 'array', maxVisible: 2 }} />}
            />
          ),
          type: "{ kind: 'array', maxVisible?: number }",
        },
      }}
    />

