import { CopyMarkdownButton } from "../_components/copy-markdown-button";

<div className="flex justify-between items-start">
  # Quick Start
  <CopyMarkdownButton />
</div>

Effortlessly display interactive, accessible UI components in chat from JSON tool outputs.

- Copy-paste components that render directly from tool JSON.
- Parse tool output into props, render components, and handle actions.
- Browse the [gallery](/docs/gallery) to see every component in action.

## Quick start (30 seconds)

<Steps>

<Step title="Server: return serializable props from a tool">

_Define your tool with a serializable schema so the LLM returns predictable props._

```ts
import { tool } from 'ai';
import { serializableDataTableSchema } from '@/components/data-table/schema';

export const tools = {
  listProducts: tool({
    outputSchema: serializableDataTableSchema,
    async execute() {
      return {
        columns: [
          { key: 'name', label: 'Product' },
          { key: 'price', label: 'Price', format: { kind: 'currency', currency: 'USD' } },
        ],
        data: [{ id: '1', name: 'Widget', price: 29.99 }],
      };
    },
  }),
} as const;
```

</Step>

<Step title="Client: parse and render">

_In the chat UI, gate on the tool part, parse the payload, and render the component._

```tsx
import { DataTable, parseSerializableDataTable } from '@/components/data-table';

if (part.type === 'tool-listProducts' && part.state === 'output-available') {
  const props = parseSerializableDataTable(part.output);
  return <DataTable rowIdKey="id" {...props} />;
}
```

</Step>

<Step title="Actions: handle clicks in your app">

_Pass row or card actions plus an `onAction` handler so your app controls follow-up work._

```tsx
<DataTable actions={[{ id: 'buy', label: 'Buy' }]} onAction={(id, row) => doSomething(id, row)} />
```

</Step>

</Steps>

More detail: [Full walkthrough](#detailed-quick-start).

> The walkthrough below uses MediaCard, but the exact parse → render → action pattern applies to Data Table, Decision Prompt, Social Post, and other components.

## Mental model

```
Tool returns JSON (validated by Zod)
        ↓
parseSerializableX → render component
        ↓
onAction → your app handles it (server/client)
```

## Choosing the right Tool UI for the job

Need help deciding between Data Table, Media Card, Decision Prompt, Social Post, or the Markdown table pattern? Jump to the [Overview → Choosing the right Tool UI for the job](/docs/overview#choose-the-right-renderer) section for chat-specific guidance.

## Schema-first DX

All components validate serializable props via Zod; parse on the client before rendering to keep server and UI in sync. Import `tool` from `ai` and the component's serializable schema, then keep the server return serializable.

```ts
const tools = {
  preview: tool({
    outputSchema: serializableMediaCardSchema,
    async execute() {
      return { id: 'card-1', kind: 'link', href: 'https://example.com' };
    },
  }),
};
```

Full walkthrough sits in the [Detailed quick start](#detailed-quick-start) below.

## What Tool UI is not

- A state manager or agent framework — you still orchestrate memory and planning.
- A server action dispatcher — you wire `onAction` callbacks to your own functions.
- A design-system replacement — components compose shadcn primitives and stay narrowly scoped to chat.

## Accessibility & compatibility

Tool UI ships WCAG-friendly defaults, tested keyboard flows, and works in any Next.js / React app with the AI SDK; see [Accessibility](/docs/accessibility) for specifics and supported browsers.

<div id="detailed-quick-start" />

## Detailed quick start

Use the example below to wire Tool UI end-to-end.

### Prerequisites

<Tabs items={["pnpm", "npm", "yarn", "bun"]}>
  <Tab>
    ```sh
    pnpm add ai @ai-sdk/openai @ai-sdk/react zod
    ```
  </Tab>
  <Tab>
    ```sh
    npm install ai @ai-sdk/openai @ai-sdk/react zod
    ```
  </Tab>
  <Tab>
    ```sh
    yarn add ai @ai-sdk/openai @ai-sdk/react zod
    ```
  </Tab>
  <Tab>
    ```sh
    bun add ai @ai-sdk/openai @ai-sdk/react zod
    ```
  </Tab>
</Tabs>

Make sure you have a model key. In this example we're using the Vercel AI SDK's OpenAI adapter.

```env
OPENAI_API_KEY=sk-...
```

<Steps>

<Step>

### API route with one tool

```ts title="app/api/chat/route.ts"
import { streamText, convertToModelMessages, tool, type UIMessage } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';
import { serializableMediaCardSchema } from '@/components/media-card/schema';

export const maxDuration = 30;

export async function POST(req: Request) {
  const { messages }: { messages: UIMessage[] } = await req.json();

  const result = streamText({
    model: openai('gpt-4o'),
    messages: convertToModelMessages(messages),
    tools: {
      previewLink: tool({
        description: 'Return a simple link preview',
        inputSchema: z.object({ url: z.string().url() }),
        outputSchema: serializableMediaCardSchema,
        async execute({ url }) {
          return {
            id: 'link-1',
            kind: 'link',
            href: url,
            title: 'React — Server Components',
            thumb: 'https://images.unsplash.com/photo-1633356122544-f134324a6cee?auto=format&fit=crop&q=80&w=1200',
          };
        },
      }),
    },
  });

  return result.toUIMessageStreamResponse();
}
```

Swap `openai('gpt-4o')` for any AI SDK model or provider; see the [AI SDK docs](https://sdk.vercel.ai/docs).

</Step>

<Step>

### Minimal client

```tsx title="app/page.tsx"
'use client';

import { useChat } from '@ai-sdk/react';
import { DefaultChatTransport } from 'ai';
import { MediaCard, parseSerializableMediaCard } from '@/components/media-card';
import { useState } from 'react';

export default function Chat() {
  const { messages, sendMessage } = useChat({
    transport: new DefaultChatTransport({ api: '/api/chat' }), // Match this to your API route
  });
  const [input, setInput] = useState('Preview https://react.dev');

  return (
    <form
      onSubmit={(e) => {
        e.preventDefault();
        if (input.trim()) {
          sendMessage({ text: input });
          setInput('');
        }
      }}
    >
      <div>
        {messages.map((m) => (
          <div key={m.id}>
            {m.parts.map((part, i) => {
              if (part.type === 'tool-previewLink' && part.state === 'output-available') {
                const card = parseSerializableMediaCard(part.output);
                return <MediaCard key={i} {...card} maxWidth="420px" />;
              }
              if (part.type === 'text') return <span key={i}>{part.text}</span>;
              return null;
            })}
          </div>
        ))}
      </div>

      <div className="mt-4 flex gap-2">
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Try: Preview https://react.dev"
          className="min-w-0 flex-1 rounded border px-3 py-2"
        />
        <button type="submit" className="rounded bg-primary px-3 py-2 text-primary-foreground">Send</button>
      </div>
    </form>
  );
}
```

</Step>

</Steps>

> **Common errors**
> - Missing `@ai-sdk/react` when using `useChat` (install it with the commands above).
> - Forgetting to `parseSerializableX` before rendering, which causes prop shape mismatches.
> - Missing or invalid `OPENAI_API_KEY`, resulting in 401 responses from your model provider.