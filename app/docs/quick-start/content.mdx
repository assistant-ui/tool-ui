import { DocsHeader } from "../_components/docs-header";

<DocsHeader title="Quick Start" />

Get Tool UI working in your chat app in under 5 minutes. This guide walks through setting up a tool that returns structured JSON and rendering it as interactive UI.

## 30-second overview

<Steps>

<Step title="Server: return serializable props">

Define your tool with a serializable schema so LLM outputs stay predictable.

```ts
import { tool } from 'ai';
import { serializableDataTableSchema } from '@/components/data-table/schema';

export const tools = {
  listProducts: tool({
    outputSchema: serializableDataTableSchema,
    async execute() {
      return {
        columns: [
          { key: 'name', label: 'Product' },
          { key: 'price', label: 'Price', format: { kind: 'currency', currency: 'USD' } },
        ],
        data: [{ id: '1', name: 'Widget', price: 29.99 }],
      };
    },
  }),
} as const;
```

</Step>

<Step title="Client: parse and render">

Check for the tool output part, parse it, and render the component.

```tsx
import { DataTable, parseSerializableDataTable } from '@/components/data-table';

if (part.type === 'tool-listProducts' && part.state === 'output-available') {
  const props = parseSerializableDataTable(part.output);
  return <DataTable rowIdKey="id" {...props} />;
}
```

</Step>

<Step title="Actions: handle clicks">

Attach actions and handle them in your app so follow-up behavior stays under your control.

```tsx
<DataTable
  actions={[{ id: 'buy', label: 'Buy' }]}
  onAction={(id, row) => handlePurchase(id, row)}
/>
```

</Step>

</Steps>

> **Component choice:** This example uses Data Table, but the parse → render → action pattern is identical for [Media Card](/docs/media-card), [Decision Prompt](/docs/decision-prompt), and [Social Post](/docs/social-post). See [Overview → Choosing the right component](/docs/overview#choose-the-renderer) for guidance.



## Full walkthrough

Follow these steps for a complete working example using Media Card.

### Prerequisites

<Tabs items={["pnpm", "npm", "yarn", "bun"]}>
  <Tab>
    ```sh
    pnpm add ai @ai-sdk/openai @ai-sdk/react zod
    ```
  </Tab>
  <Tab>
    ```sh
    npm install ai @ai-sdk/openai @ai-sdk/react zod
    ```
  </Tab>
  <Tab>
    ```sh
    yarn add ai @ai-sdk/openai @ai-sdk/react zod
    ```
  </Tab>
  <Tab>
    ```sh
    bun add ai @ai-sdk/openai @ai-sdk/react zod
    ```
  </Tab>
</Tabs>

**Set up your API key**

```env title=".env.local"
OPENAI_API_KEY=sk-...
```

You can use any AI SDK provider—swap `@ai-sdk/openai` for `@ai-sdk/anthropic`, `@ai-sdk/google`, etc. See the [AI SDK docs](https://sdk.vercel.ai/docs/foundations/providers-and-models) for all options.

**Get the component**

Visit the [Media Card component](/docs/media-card) page and use the "Source & install" section to either:
- Download the ZIP and extract to your project's `components/` directory
- Clone from the GitHub repo link

The component should end up at `components/media-card/` in your project.

<Steps>

<Step>

### Create the API route

Define a tool that returns serializable Media Card props.

```ts title="app/api/chat/route.ts"
import { streamText, convertToModelMessages, tool, type UIMessage } from 'ai';
import { openai } from '@ai-sdk/openai';
import { z } from 'zod';
import { serializableMediaCardSchema } from '@/components/media-card/schema';

export const maxDuration = 30;

export async function POST(req: Request) {
  const { messages }: { messages: UIMessage[] } = await req.json();

  const result = streamText({
    model: openai('gpt-4o'),
    messages: convertToModelMessages(messages),
    tools: {
      previewLink: tool({
        description: 'Show a preview card for a URL',
        inputSchema: z.object({ url: z.string().url() }),
        outputSchema: serializableMediaCardSchema,
        async execute({ url }) {
          // In production, fetch real metadata from the URL
          return {
            id: 'link-1',
            kind: 'link',
            href: url,
            title: 'React Documentation',
            description: 'Learn React with our comprehensive guide',
            thumb: 'https://images.unsplash.com/photo-1633356122544-f134324a6cee?auto=format&fit=crop&q=80&w=1200',
          };
        },
      }),
    },
  });

  return result.toUIMessageStreamResponse();
}
```

**Key points**
- `outputSchema` ensures type safety and validates tool outputs
- Return serializable data only (no functions, Dates, or class instances)
- Tool description helps the LLM decide when to call it

</Step>

<Step>

### Build the chat UI

Parse tool outputs and render components in your message list.

```tsx title="app/page.tsx"
'use client';

import { useChat } from '@ai-sdk/react';
import { DefaultChatTransport } from 'ai';
import { MediaCard, parseSerializableMediaCard } from '@/components/media-card';
import { useState } from 'react';

export default function Chat() {
  const { messages, sendMessage } = useChat({
    transport: new DefaultChatTransport({ api: '/api/chat' }),
  });
  const [input, setInput] = useState('Preview https://react.dev');

  return (
    <div className="flex h-screen flex-col">
      {/* Message list */}
      <div className="flex-1 overflow-y-auto p-4">
        {messages.map((m) => (
          <div key={m.id} className="mb-4">
            <div className="font-semibold">{m.role === 'user' ? 'You' : 'Assistant'}</div>
            {m.parts.map((part, i) => {
              // Render tool output as Media Card
              if (part.type === 'tool-previewLink' && part.state === 'output-available') {
                const card = parseSerializableMediaCard(part.output);
                return <MediaCard key={i} {...card} maxWidth="420px" />;
              }
              // Render text
              if (part.type === 'text') {
                return <p key={i} className="text-sm">{part.text}</p>;
              }
              return null;
            })}
          </div>
        ))}
      </div>

      {/* Input form */}
      <form
        onSubmit={(e) => {
          e.preventDefault();
          if (input.trim()) {
            sendMessage({ text: input });
            setInput('');
          }
        }}
        className="border-t p-4"
      >
        <div className="flex gap-2">
          <input
            value={input}
            onChange={(e) => setInput(e.target.value)}
            placeholder="Try: Preview https://react.dev"
            className="min-w-0 flex-1 rounded border px-3 py-2"
          />
          <button type="submit" className="rounded bg-primary px-4 py-2 text-primary-foreground">
            Send
          </button>
        </div>
      </form>
    </div>
  );
}
```

**Key points**
- Check `part.type` to identify which tool was called
- Check `part.state === 'output-available'` before parsing
- Always call `parseSerializableX` to validate and transform props

</Step>

<Step>

### Add actions (optional)

Wire up click handlers to let users interact with rendered components.

```tsx
const card = parseSerializableMediaCard(part.output);
return (
  <MediaCard
    {...card}
    maxWidth="420px"
    actions={[
      { id: 'open', label: 'Open' },
      { id: 'save', label: 'Save' },
    ]}
    onAction={(actionId, cardData) => {
      if (actionId === 'open') {
        window.open(cardData.href, '_blank');
      }
      if (actionId === 'save') {
        // Handle save logic
        console.log('Saving', cardData);
      }
    }}
  />
);
```

**Key points**
- Actions are optional—components work without them
- `onAction` receives the action ID and component data
- Handle actions client-side or send to server actions

</Step>

</Steps>


## Next steps

- **Explore components**: Browse the [component gallery](/docs/gallery) to see all available UI patterns
- **Add more tools**: Each component page has copy-paste schemas and examples
- **Handle actions**: Wire `onAction` to server actions or client handlers for interactive flows
- **Customize styling**: All components accept Tailwind classes via `className` props

Need conceptual background? See the [Overview](/docs/overview) for architecture details and component selection guidance.
