"use client";

import { useCallback } from "react";
import type { WeatherCondition } from "@/components/tool-ui/weather-widget/schema";
import type { CheckpointOverrides, ConditionOverrides } from "../../weather-compositor/presets";
import { WEATHER_CONDITIONS } from "../../weather-compositor/presets";
import type { TimeCheckpoint } from "../types";

type ExportFormat = "json-overrides" | "json-full" | "typescript";

interface ExportOptions {
  format: ExportFormat;
  conditions?: WeatherCondition[];
  includeMetadata?: boolean;
}

const CHECKPOINTS: TimeCheckpoint[] = ["dawn", "noon", "dusk", "midnight"];

export function useCodeGen(
  checkpointOverrides: Partial<Record<WeatherCondition, CheckpointOverrides>>,
  signedOff: Set<WeatherCondition>
) {
  const generateJson = useCallback(
    (options: ExportOptions): string => {
      const conditionsToExport =
        options.conditions ?? WEATHER_CONDITIONS.filter((c) => checkpointOverrides[c]);

      const data: Record<string, unknown> = {};

      if (options.includeMetadata) {
        data.exportedAt = new Date().toISOString();
        data.signedOff = Array.from(signedOff);
        data.version = 2;
      }

      data.checkpointOverrides = {};
      for (const condition of conditionsToExport) {
        if (checkpointOverrides[condition]) {
          (data.checkpointOverrides as Record<string, CheckpointOverrides>)[condition] =
            checkpointOverrides[condition]!;
        }
      }

      return JSON.stringify(data, null, 2);
    },
    [checkpointOverrides, signedOff]
  );

  const generateConditionOverrideCode = (conditionOverride: ConditionOverrides, indent: string): string[] => {
    const lines: string[] = [];

    if (conditionOverride.layers) {
      lines.push(`${indent}layers: {`);
      for (const [key, value] of Object.entries(conditionOverride.layers)) {
        lines.push(`${indent}  ${key}: ${JSON.stringify(value)},`);
      }
      lines.push(`${indent}},`);
    }

    if (conditionOverride.celestial) {
      lines.push(`${indent}celestial: {`);
      for (const [key, value] of Object.entries(conditionOverride.celestial)) {
        lines.push(`${indent}  ${key}: ${typeof value === "number" ? value.toFixed(4) : JSON.stringify(value)},`);
      }
      lines.push(`${indent}},`);
    }

    if (conditionOverride.cloud) {
      lines.push(`${indent}cloud: {`);
      for (const [key, value] of Object.entries(conditionOverride.cloud)) {
        lines.push(`${indent}  ${key}: ${typeof value === "number" ? value.toFixed(4) : JSON.stringify(value)},`);
      }
      lines.push(`${indent}},`);
    }

    if (conditionOverride.rain) {
      lines.push(`${indent}rain: {`);
      for (const [key, value] of Object.entries(conditionOverride.rain)) {
        lines.push(`${indent}  ${key}: ${typeof value === "number" ? value.toFixed(4) : JSON.stringify(value)},`);
      }
      lines.push(`${indent}},`);
    }

    if (conditionOverride.lightning) {
      lines.push(`${indent}lightning: {`);
      for (const [key, value] of Object.entries(conditionOverride.lightning)) {
        lines.push(`${indent}  ${key}: ${typeof value === "number" ? value.toFixed(4) : JSON.stringify(value)},`);
      }
      lines.push(`${indent}},`);
    }

    if (conditionOverride.snow) {
      lines.push(`${indent}snow: {`);
      for (const [key, value] of Object.entries(conditionOverride.snow)) {
        lines.push(`${indent}  ${key}: ${typeof value === "number" ? value.toFixed(4) : JSON.stringify(value)},`);
      }
      lines.push(`${indent}},`);
    }

    return lines;
  };

  const generateTypeScript = useCallback((): string => {
    const lines: string[] = [
      "// Generated by Weather Tuning Studio",
      `// Exported at: ${new Date().toISOString()}`,
      "",
      "import type { CheckpointOverrides } from './presets';",
      "import type { WeatherCondition } from '@/components/tool-ui/weather-widget/schema';",
      "",
      "export const TUNED_CHECKPOINT_OVERRIDES: Partial<Record<WeatherCondition, CheckpointOverrides>> = {",
    ];

    for (const condition of WEATHER_CONDITIONS) {
      const conditionCheckpoints = checkpointOverrides[condition];
      if (!conditionCheckpoints) continue;

      const isSignedOff = signedOff.has(condition);
      lines.push(`  // ${condition}${isSignedOff ? " âœ“ signed off" : ""}`);
      lines.push(`  "${condition}": {`);

      for (const checkpoint of CHECKPOINTS) {
        const checkpointData = conditionCheckpoints[checkpoint];
        if (!checkpointData || Object.keys(checkpointData).length === 0) {
          lines.push(`    ${checkpoint}: {},`);
          continue;
        }

        lines.push(`    ${checkpoint}: {`);
        const overrideLines = generateConditionOverrideCode(checkpointData, "      ");
        lines.push(...overrideLines);
        lines.push("    },");
      }

      lines.push("  },");
    }

    lines.push("};");
    lines.push("");

    return lines.join("\n");
  }, [checkpointOverrides, signedOff]);

  const copyToClipboard = useCallback(
    async (options: ExportOptions): Promise<void> => {
      let content: string;

      if (options.format === "typescript") {
        content = generateTypeScript();
      } else {
        content = generateJson(options);
      }

      await navigator.clipboard.writeText(content);
    },
    [generateJson, generateTypeScript]
  );

  const downloadFile = useCallback(
    (options: ExportOptions): void => {
      let content: string;
      let filename: string;
      let mimeType: string;

      if (options.format === "typescript") {
        content = generateTypeScript();
        filename = "tuned-overrides.ts";
        mimeType = "text/typescript";
      } else {
        content = generateJson(options);
        filename = "weather-tuning-export.json";
        mimeType = "application/json";
      }

      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    },
    [generateJson, generateTypeScript]
  );

  return {
    generateJson,
    generateTypeScript,
    copyToClipboard,
    downloadFile,
  };
}
